<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Python源码剖析】PyDictObject]]></title>
    <url>%2F2018%2F07%2F15%2FPython%E5%AD%97%E5%85%B8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[参考 python.org文档 PEP412 《Python源码剖析》—— 陈儒 InterfacePython官网把 PyDictObject 归类与 Concrete Objects Layer，享受同样待遇的还有PySetObject。在前面 PythonUnicodeObject 中，我们已经见到了 PythonDict 的运用，即共享机制 interned。在 Python 世界里，字典被用于建立字节码的运行环境，用来存放变量名和变量值，意味着做任何操作几乎都要设计到 PythonDict， 因此，对搜索的效率要求及其苛刻。因而采用的 HashTable(散列表)，在最优情况下能达到O(1)。散列表的基本思想是，将键映射为一个整数，把整数作为索引访问内存。主要逻辑是：查询键值 ——散列函数 hash function —— 散列值 hash value —— 内存区域 —— 查询结果——散列冲突。Python 处理散列冲突的问题，采用的是 开放定址法。删除探测链上元素，采用的是伪删除。 因为字典的重要性，Python 甚至单独在Objects/dictnotes.txt中写入了关于字典的说明，下面仅挑选部分内容：123456789101112131415161718192021222324252627281. 主要应用 1. 传递关键字参数（1~3个元素） 2. 类方法查找： 1. 通常包含 8~16 个元素。 2. 通常只写入一次，但多次查找 3. 当使用基类时，会频繁在基类中查找 3. 实例属性查找、全局变量查找 1. 通常包含 4~10 个元素。 2. 写入和读取都非常频繁 4. Builtins（内置命令） 1. 频繁的读取，几乎不写入 2. About 150 interned strings (as of Py3.3). 3. 其中一切访问频率远大于其他2. 数据存储 由3部分组成： 1. dictobject 自身 2. A dict-keys object (keys &amp; hashes) 3. A values array仅涉及单个键的字典操作可以是O（1），除非涉及到调整大小。现在的版本与之前的差别： 1. key value 可以分开存储 2. 分离表中 key-val 新增组合 (key, NULL)，代表被删除 3. key-val表中，不能嵌套小表 4. 一般字典比以前略大 5. 单个类的所有对象，共享key表，节约大量内存 PyDict_Type12345678910111213141516// dictobject.c.3282PyTypeObject PyDict_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "dict", sizeof(PyDictObject), (destructor)dict_dealloc, /* tp_dealloc */ &amp;dict_as_sequence, /* tp_as_sequence */ &amp;dict_as_mapping, /* tp_as_mapping */ PyObject_HashNotImplemented, /* tp_hash */ (getiterfunc)dict_iter, /* tp_iter */ mapp_methods, /* tp_methods */ dict_init, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ dict_new, /* tp_new */ PyObject_GC_Del, /* tp_free */&#125;; PyDictObject1234567891011121314151617181920212223// dictobject.h.18typedef struct _dictkeysobject PyDictKeysObject;typedef struct &#123; PyObject_HEAD /* Number of items in the dictionary */ Py_ssize_t ma_used; /* Dictionary version: globally unique, value change each time the dictionary is modified */ uint64_t ma_version_tag; PyDictKeysObject *ma_keys; /* If ma_values is NULL, the table is "combined": keys and values are stored in ma_keys. If ma_values is not NULL, the table is splitted: keys are stored in ma_keys and values are stored in ma_values */ PyObject **ma_values;&#125; PyDictObject; 如上，不同于之前的 PyListObject/PyUnicodeObject，他们被归类于 Sequence Object。而PyDictObject 归类于 Concrete Objects。因此，直接定义为 PyObject_HEAD。其他字段含义，见注释。 既然是分离设计，那么必然存在两个储存表的地方，一个是 ma_keys，一个是ma_values。具体内容见下文注释。1234567891011The DictObject can be in one of two forms.A combined table: ma_values == NULL, dk_refcnt == 1. Values are stored in the me_value field of the PyDictKeysObject.A split table: ma_values != NULL, dk_refcnt &gt;= 1 Values are stored in the ma_values array. Only string (unicode) keys are allowed. All dicts sharing same key must have same insertion order. PyDictKeysObject1234567891011121314// dict-common.h/23struct _dictkeysobject &#123; Py_ssize_t dk_refcnt; Py_ssize_t dk_size; dict_lookup_func dk_lookup; Py_ssize_t dk_usable; Py_ssize_t dk_nentries; union &#123; int8_t as_1[8]; int16_t as_2[4]; int32_t as_4[2]; int64_t as_8[1]; &#125; dk_indices;&#125;; PyDictKeysObject 实现了字典的 hash table，布局如下: layout1234567891011121314151617181920212223+---------------+| dk_refcnt || dk_size | /* Size of the hash table.| | It must be a power of 2. */| dk_lookup | /* Function to lookup in the hash table. */| dk_usable | /* Number of usable entries in dk_entries. */| dk_nentries | /* Number of used entries in dk_entries. */+---------------+| dk_indices | // Actual hash table of dk_size entries.| |+---------------+| dk_entries | /* array of PyDictKeyEntry.| | len(dk_entries) == USABLE_FRACTION(dk_size) */+---------------+The size in bytes of an indice depends on dk_size:- 1 byte if dk_size &lt;= 0xff (char*)- 2 bytes if dk_size &lt;= 0xffff (int16_t*)- 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)- 8 bytes otherwise (int64_t*)Dynamically sized, 8 is minimum. 需要注意的是，dk_indices 是一个共用体，会根据 dk_size 的值，决定存储 index 的类型。 PyDictKeyEntry1234567891011// dict-common.h.17#define DKIX_EMPTY (-1)#define DKIX_DUMMY (-2) /* Used internally */#define DKIX_ERROR (-3)// dict-common.h.4typedef struct &#123; Py_hash_t me_hash; /* Cached hash code of me_key. */ PyObject *me_key; PyObject *me_value; /* only meaningful for combined tables */&#125; PyDictKeyEntry; dk_entries中存储的是 PyDictKeyEntry对象，其中每个元素都可以称为一个 enrty。因为使用了负数作为 entry 的状态，因此dk_indices中存储的是有符号整数。可以通过 宏 DK_ENTRIES 访问 entry：1234567891011// dictobject.c.289#define DK_SIZE(dk) ((dk)-&gt;dk_size)#define DK_IXSIZE(dk) \ (DK_SIZE(dk) &lt;= 0xff ? \ 1 : DK_SIZE(dk) &lt;= 0xffff ? \ 2 : DK_SIZE(dk) &lt;= 0xffffffff ? \ 4 : sizeof(int64_t))#define DK_ENTRIES(dk) \ ((PyDictKeyEntry*)(&amp;(dk)-&gt;dk_indices.as_1[DK_SIZE(dk) * DK_IXSIZE(dk)])) dk_indicesdk_indices 即是真正的 hash table，对应一个 slot 数组，每个slot 有四种状态1234567891011121314151617181920// dictobject.c.641. Unused. index == DKIX_EMPTY This is each slot's initial state. Does not hold an active (key, value) pair now and never did. Unused can transition to Active upon key insertion.2. Active. index &gt;= 0, me_key != NULL and me_value != NULL Holds an active (key, value) pair. This is the only case in which me_value != NULL. Active can transition to Dummy or Pending upon key deletion~~~~ (for combined and split tables respectively).3. Dummy. index == DKIX_DUMMY (combined only) Previously held an active (key, value) pair, but that was deleted and an active pair has not yet overwritten the slot. Dummy can transition to Active upon key insertion. Dummy slots cannot be made Unused again.4. Pending. index &gt;= 0, key != NULL, and value == NULL (split only) Not yet inserted in split-table. 简单来说就是 Unused，初始状态，该 slot 没有被使用，index = -1 Active，正在使用，index &gt; 0 Dummy，曾经使用过，但现在被删除了，index = -2 。(仅限 combined-table) Pending，还未插入。(仅限 split-table)正因为 Dummy 态不能转换为 Unused，所以保证了探测链的连续性，对应前文说的 伪删除。 创建12345678910#define PyDict_MINSIZE 8// dictobject.c.620PyObject * PyDict_New(void)&#123; PyDictKeysObject *keys = new_keys_object(PyDict_MINSIZE); if (keys == NULL) return NULL; return new_dict(keys, NULL);&#125; PyDict_MINSIZE 是任何新 Dict 的起始大小，默认为8，满足运行过程中大量的函数参数传递过程。 new_keys_object12345678910111213141516171819202122232425262728293031323334353637383940414243// dictobject.c.374#define USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)static PyDictKeysObject *new_keys_object(Py_ssize_t size)&#123; PyDictKeysObject *dk; Py_ssize_t es, usable; // dk_size &gt;= 8 and must be a power of 2. assert(size &gt;= PyDict_MINSIZE); assert(IS_POWER_OF_2(size)); // len(dk_entries) == USABLE_FRACTION(dk_size)，最小为5 usable = USABLE_FRACTION(size); ... // es = 1/2/3/4; 根据 size 大小，确定存储位数 // 尝试共享 if (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; 0) &#123; dk = keys_free_list[--numfreekeys]; &#125; else &#123; dk = PyObject_MALLOC(sizeof(PyDictKeysObject) - Py_MEMBER_SIZE(PyDictKeysObject, dk_indices) + es * size + sizeof(PyDictKeyEntry) * usable); if (dk == NULL) &#123; PyErr_NoMemory(); return NULL; &#125; &#125; DK_DEBUG_INCREF dk-&gt;dk_refcnt = 1; dk-&gt;dk_size = size; dk-&gt;dk_usable = usable; dk-&gt;dk_lookup = lookdict_unicode_nodummy; dk-&gt;dk_nentries = 0; // 初始化 dk_indices == -1 memset(&amp;dk-&gt;dk_indices.as_1[0], 0xff, es * size); // 初始化 dk_entries == 0 memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable); return dk;&#125; 从代码中也清晰的看见，对象缓冲池 keys_free_list 的身影。其中需要注意的是： 1usable = USABLE_FRACTION(size); // (((n) &lt;&lt; 1)/3) size 默认为 PyDict_MINSIZE 即8。通过计算可以得出默认存放5个对象。 new_dict1234567891011121314151617181920212223242526// dictobject.c.573static PyObject *new_dict(PyDictKeysObject *keys, PyObject **values)&#123; PyDictObject *mp; // 尝试共享 if (numfree) &#123; mp = free_list[--numfree]; _Py_NewReference((PyObject *)mp); &#125; else &#123; mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type); if (mp == NULL) &#123; DK_DECREF(keys); free_values(values); return NULL; &#125; &#125; mp-&gt;ma_keys = keys; mp-&gt;ma_values = values; mp-&gt;ma_used = 0; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); return (PyObject *)mp;&#125; 代码不长，很好懂。再次发现了对象池 free_list。 共享机制前面 创建 PyDictObject 和 PyDictKeysObject 时，都利用了对象缓冲池。12345#define PyDict_MAXFREELIST 80static PyDictObject *free_list[PyDict_MAXFREELIST];static int numfree = 0;static PyDictKeysObject *keys_free_list[PyDict_MAXFREELIST];static int numfreekeys = 0; 宏定义如上，与 PyListObject 类似，甚至连名字都类似。那么必然的，销毁对象时，会把对象放入缓冲池。 dict_dealloc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static PyObject *empty_values[1] = &#123; NULL &#125;;// dictobject.c.2003static void dict_dealloc(PyDictObject *mp)&#123; PyObject **values = mp-&gt;ma_values; PyDictKeysObject *keys = mp-&gt;ma_keys; Py_ssize_t i, n; /* bpo-31095: UnTrack is needed before calling any callbacks */ PyObject_GC_UnTrack(mp); Py_TRASHCAN_SAFE_BEGIN(mp) if (values != NULL) &#123; if (values != empty_values) &#123; for (i = 0, n = mp-&gt;ma_keys-&gt;dk_nentries; i &lt; n; i++) &#123; Py_XDECREF(values[i]); &#125; free_values(values); &#125; DK_DECREF(keys); &#125; else if (keys != NULL) &#123; assert(keys-&gt;dk_refcnt == 1); DK_DECREF(keys); &#125; // 尝试共享 if (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type) free_list[numfree++] = mp; else Py_TYPE(mp)-&gt;tp_free((PyObject *)mp); Py_TRASHCAN_SAFE_END(mp)&#125;// dictobject.c.554static void free_keys_object(PyDictKeysObject *keys)&#123; PyDictKeyEntry *entries = DK_ENTRIES(keys); Py_ssize_t i, n; for (i = 0, n = keys-&gt;dk_nentries; i &lt; n; i++) &#123; Py_XDECREF(entries[i].me_key); Py_XDECREF(entries[i].me_value); &#125; // 尝试共享 if (keys-&gt;dk_size == PyDict_MINSIZE &amp;&amp; numfreekeys &lt; PyDict_MAXFREELIST) &#123; keys_free_list[numfreekeys++] = keys; return; &#125; PyObject_FREE(keys);&#125; CRUDMapping方法簇12345678910static PyMappingMethods dict_as_mapping = &#123; (lenfunc)dict_length, /*mp_length*/ (binaryfunc)dict_subscript, /*mp_subscript*/ (objobjargproc)dict_ass_sub, /*mp_ass_subscript*/&#125;;static Py_ssize_t dict_length(PyDictObject *mp)&#123; return mp-&gt;ma_used;&#125; PyDict_Type 中定义的 tp_as_mapping == &amp;dict_as_mapping。从代码中可以看见len(dict)时间复杂度为O(1)。执行 dict[item] 即调用 dict_subscript()。 GetItem12345678910111213141516171819202122232425262728293031323334353637383940414243// dictobject.c.2172static PyObject * dict_subscript(PyDictObject *mp, PyObject *key)&#123; PyObject *v; Py_ssize_t ix; Py_hash_t hash; PyObject **value_addr; // 1. 获取/计算 hash 值 if (!PyUnicode_CheckExact(key) || (hash = ((PyASCIIObject *) key)-&gt;hash) == -1) &#123; hash = PyObject_Hash(key); if (hash == -1) return NULL; &#125; // 2. 查找 index ，返回 ix&gt;0 或 ix == -1 / -3 ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;value_addr, NULL); if (ix == DKIX_ERROR) // -3 return NULL; // 3. 根据 ix 结果值，执行 __miss__ 或 返回结果 if (ix == DKIX_EMPTY || *value_addr == NULL) &#123; if (!PyDict_CheckExact(mp)) &#123; /* Look up __missing__ method if we're a subclass. */ PyObject *missing, *res; _Py_IDENTIFIER(__missing__); missing = _PyObject_LookupSpecial((PyObject *)mp, &amp;PyId___missing__); if (missing != NULL) &#123; res = PyObject_CallFunctionObjArgs(missing, key, NULL); Py_DECREF(missing); return res; &#125; else if (PyErr_Occurred()) return NULL; &#125; _PyErr_SetKeyError(key); return NULL; &#125; v = *value_addr; Py_INCREF(v); return v;&#125; 源码如上，需要注意的的是，返回的是 对象引用。并且，时间复杂度为O(1)。 ix 获取方式 mp-&gt;ma_keys-&gt;dk_lookup，即调用 PyDictObject 自身的 dk_lookup，在前面的 PyDict_New 中，可以发现 dk-&gt;dk_lookup = lookdict_unicode_nodummy。实际上，dk_lookup 存在不止一种。 dk_lookup123456789101112131415161718192021222324252627// ictobject.c.224/* lookdict() is general-purpose, and may return DKIX_ERROR if (and only if) a comparison raises an exception. */static Py_ssize_t lookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos);/* Specialized version for string-only keys */static Py_ssize_t lookdict_unicode(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos);/* Faster version of lookdict_unicode when it is known that no &lt;dummy&gt; keys * will be present. */static Py_ssize_tlookdict_unicode_nodummy(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos);/* Version of lookdict for split tables. * All split tables and only split tables use this lookup function. * Split tables only contain unicode keys and no dummy keys, * so algorithm is the same as lookdict_unicode_nodummy. */static Py_ssize_t lookdict_split(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos); 如上，dk_lookup 有4个非常相似的 查找函数。因为在 Python 中，大量使用 str 作为字典的 key，因此会有2个特定针对 str 对象的 优化版本。 lookdict123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113static Py_ssize_tlookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos)&#123; size_t i, mask; Py_ssize_t ix, freeslot; int cmp; PyDictKeysObject *dk; PyDictKeyEntry *ep0, *ep; PyObject *startkey;top: dk = mp-&gt;ma_keys; mask = DK_MASK(dk); ep0 = DK_ENTRIES(dk); i = (size_t)hash &amp; mask; ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) *hashpos = i; *value_addr = NULL; return DKIX_EMPTY; &#125; if (ix == DKIX_DUMMY) &#123; freeslot = i; &#125; else &#123; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125; freeslot = -1; &#125; for (size_t perturb = hash;;) &#123; perturb &gt;&gt;= PERTURB_SHIFT; i = ((i &lt;&lt; 2) + i + perturb + 1) &amp; mask; ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) &#123; *hashpos = (freeslot == -1) ? (Py_ssize_t)i : freeslot; &#125; *value_addr = NULL; return ix; &#125; if (ix == DKIX_DUMMY) &#123; if (freeslot == -1) freeslot = i; continue; &#125; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125; &#125; assert(0); /* NOT REACHED */ return 0;&#125; 如上，通用的 lookdict 代码很长。大概可以分为 以下几部分 ix = ?12345678910111213#define DK_MASK(dk) (((dk)-&gt;dk_size)-1)static Py_ssize_tlookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos)&#123; size_t i, mask; PyDictKeysObject *dk; dk = mp-&gt;ma_keys; mask = DK_MASK(dk); i = (size_t)hash &amp; mask; // hash%dk_size == hash &amp; (dk_size - 1)&#125; 前面已经知道： hash == PyObject_Hash(key) dk_size &gt;= 8 &amp;&amp; IS_POWER_OF_2 注意最后一行，将 hash 值映射到数组上 if ix == DKIX_EMPTY1234567891011121314static Py_ssize_tlookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos)&#123; /* lookup indices. returns DKIX_EMPTY, DKIX_DUMMY, or ix &gt;=0 */ ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) *hashpos = i; *value_addr = NULL; return DKIX_EMPTY; &#125;&#125; 如上，当 ix == DKIX_EMPTY 表明，slot 可用，直接返回。需要注意的是，返回之前，把 *value_addr 设为了 NULL，相当于清空了数据。 if ix != DKIX_EMPTY123456789101112131415161718192021222324252627282930313233343536373839404142PyDictKeyEntry *ep0, *ep;// DK_ENTRIES(keys)[index] if index &gt;= 0ep0 = DK_ENTRIES(dk);if (ix == DKIX_DUMMY) &#123; freeslot = i; // 伪删除，me_value==NULL&#125;else &#123; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; // 引用相同 *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; // hash 相同 startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); /* cmp = startkey == key ? 1 : 0 or -1 (raise ERROR) */ Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; // 值相同 *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125; freeslot = -1;&#125; 如上，当 ix == DKIX_DUMMY 时，将 freeslot 设置为该 slot。若后续搜索没有成功找到，那么将返回该 slot。 当 ix&gt;=0 &amp;&amp; ix != DKIX_DUMMY 时，获取 Entry 对象，对其值进行判断。前面已经知道，me_hash 是 hash(me_key) 的 缓存。 接着两个 if 判断，是为了优先考虑引用相同，接着再考虑引用不同而值相同。因为 Python 内部存在对象缓冲池，小整数，字符串等具有相同的对象引用，而对于1024等大整数，就必须判断 引用不一样而值一样。 PyObject_RichCompareBool 是传入操作数与操作符，返回数值。 若cmp==1，即 hash,value 都相等，正确返回。 若cmp==0，即 hash相等，值不等，即 hash 冲突。 解决 hash 冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*执行循环的 前提条件：if ix == DKIX_DUMMY： freeslot = ielif ix&gt;=0 and hash冲突: freeslot = -1;*/#define PERTURB_SHIFT 5for (size_t perturb = hash;;) &#123; // 探测链算法 perturb &gt;&gt;= PERTURB_SHIFT; i = ((i &lt;&lt; 2) + i + perturb + 1) &amp; mask; ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) &#123; *hashpos = (freeslot == -1) ? (Py_ssize_t)i : freeslot; /* 找到一个 UnusedEnpty，表明搜索失败 1. freeslot 不存在，返回现在的 2. freeslot 已经有一个，返回第一个 */ &#125; *value_addr = NULL; return ix; &#125; if (ix == DKIX_DUMMY) &#123; // 探测链 继续寻找 if (freeslot == -1) freeslot = i; continue; &#125; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; // 引用相同 if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; // 值相同 if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125;&#125; 如上，整个过程是，当发生冲突时，再次计算获取一个 i 值，最终返回 NUll 或 目标值。 SetItemdict_ass_sub123456789101112131415161718192021222324252627282930313233343536// dictobject.c.2163static intdict_ass_sub(PyDictObject *mp, PyObject *v, PyObject *w)&#123; if (w == NULL) return PyDict_DelItem((PyObject *)mp, v); else return PyDict_SetItem((PyObject *)mp, v, w);&#125;// dictobject.c.1554intPyDict_SetItem(PyObject *op, PyObject *key, PyObject *value)&#123; PyDictObject *mp; Py_hash_t hash; // 类型检查 if (!PyDict_Check(op)) &#123; PyErr_BadInternalCall(); return -1; &#125; assert(key); assert(value); mp = (PyDictObject *)op; // 获取 hash 值 if (!PyUnicode_CheckExact(key) || (hash = ((PyASCIIObject *) key)-&gt;hash) == -1) &#123; hash = PyObject_Hash(key); if (hash == -1) return -1; &#125; /* insertdict() handles any resizing that might be necessary */ return insertdict(mp, key, hash, value);&#125; 执行 dict[item] = value 时，调用 dict_ass_sub()。如上，与 List 类似，SetItem 和 DelItem 都是调用同一个方法。在 PyDict_SetItem 中，仅进行类型检查，计算 hash 值，实际插入调用 insertdict。 insertdict12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// dictobject.c.1110static intinsertdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value)&#123; PyObject *old_value; PyObject **value_addr; PyDictKeyEntry *ep, *ep0; Py_ssize_t hashpos, ix; Py_INCREF(key); Py_INCREF(value); // split-table 插入 key(not Unicode) if (mp-&gt;ma_values != NULL &amp;&amp; !PyUnicode_CheckExact(key)) &#123; if (insertion_resize(mp) &lt; 0) goto Fail; &#125; // 计算 ix 的值 ix = ? ix = mp-&gt;ma_keys-&gt;dk_lookup(mp, key, hash, &amp;value_addr, &amp;hashpos); if (ix == DKIX_ERROR) goto Fail; assert(PyUnicode_CheckExact(key) || mp-&gt;ma_keys-&gt;dk_lookup == lookdict); MAINTAIN_TRACKING(mp, key, value); // split-table 插入 key(different order) if (_PyDict_HasSplitTable(mp) &amp;&amp; ((ix &gt;= 0 &amp;&amp; *value_addr == NULL &amp;&amp; mp-&gt;ma_used != ix) || (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123; if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); ix = DKIX_EMPTY; &#125; // Insert when ix == DKIX_EMPTY if (ix == DKIX_EMPTY) &#123; /* Insert into new slot. */ if (mp-&gt;ma_keys-&gt;dk_usable &lt;= 0) &#123; /* Need to resize. */ if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); &#125; ep0 = DK_ENTRIES(mp-&gt;ma_keys); ep = &amp;ep0[mp-&gt;ma_keys-&gt;dk_nentries]; dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries); ep-&gt;me_key = key; ep-&gt;me_hash = hash; if (mp-&gt;ma_values) &#123; assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == NULL); mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value; &#125; else &#123; ep-&gt;me_value = value; &#125; mp-&gt;ma_used++; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); mp-&gt;ma_keys-&gt;dk_usable--; mp-&gt;ma_keys-&gt;dk_nentries++; assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= 0); assert(_PyDict_CheckConsistency(mp)); return 0; &#125; assert(value_addr != NULL); // Insert when ix != DKIX_EMPTY old_value = *value_addr; if (old_value != NULL) &#123; *value_addr = value; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); assert(_PyDict_CheckConsistency(mp)); Py_DECREF(old_value); /* which **CAN** re-enter (see issue #22653) */ Py_DECREF(key); return 0; &#125; /* pending state */ assert(_PyDict_HasSplitTable(mp)); assert(ix == mp-&gt;ma_used); *value_addr = value; mp-&gt;ma_used++; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); assert(_PyDict_CheckConsistency(mp)); Py_DECREF(key); return 0;Fail: Py_DECREF(value); Py_DECREF(key); return -1;&#125; 如上，实际插入的对象的函数，代码也很长，需要分块处理。 split-table 插入 key(not Unicode)1234if (mp-&gt;ma_values != NULL &amp;&amp; !PyUnicode_CheckExact(key)) &#123; if (insertion_resize(mp) &lt; 0) goto Fail;&#125; 在 前面 PyDictObject 结构体定义中，有提到：1234A split table: ma_values != NULL, dk_refcnt &gt;= 1 Values are stored in the ma_values array. Only string (unicode) keys are allowed. 当，split table 插入的 key 不是 Unicode 时，调用 insertion_resize。 split-table 插入 key(different order)1234567891011/* When insertion order is different from shared key, we can't share * the key anymore. Convert this instance to combine table. */if (_PyDict_HasSplitTable(mp) &amp;&amp; ((ix &gt;= 0 &amp;&amp; *value_addr == NULL &amp;&amp; mp-&gt;ma_used != ix) || (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123; if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); ix = DKIX_EMPTY;&#125; 在 前面 PyDictObject 结构体定义中，同时有提到：12A split table: All dicts sharing same key must have same insertion order. 如源码中注释所述，当插入 顺序不一致时，将调用 insertion_resize。 Insert when ix == DKIX_EMPTY123456789101112131415161718192021222324252627282930313233if (ix == DKIX_EMPTY) &#123; /* Insert into new slot. */ if (mp-&gt;ma_keys-&gt;dk_usable &lt;= 0) &#123; /* Need to resize. */ if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); &#125; // 初始化 ep0 = DK_ENTRIES(mp-&gt;ma_keys); ep = &amp;ep0[mp-&gt;ma_keys-&gt;dk_nentries]; dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries); ep-&gt;me_key = key; ep-&gt;me_hash = hash; // 插入不同地方 if (mp-&gt;ma_values) &#123; assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == NULL); mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value; &#125; else &#123; ep-&gt;me_value = value; &#125; // 调整属性值 mp-&gt;ma_used++; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); mp-&gt;ma_keys-&gt;dk_usable--; mp-&gt;ma_keys-&gt;dk_nentries++; assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= 0); assert(_PyDict_CheckConsistency(mp)); return 0;&#125; 如上，ix == DKIX_EMPTY 时，执行插入动作。 if 可用空间 dk_usable &lt;=0，调用 insertion_resize dk_set_index，初始化 me_key, me_hash 根据 ma_values，判断 table 类型，插入 不同的地方 调整 mp 自身属性 Insert when ix != DKIX_EMPTY123456789101112131415161718192021assert(value_addr != NULL);old_value = *value_addr;if (old_value != NULL) &#123; *value_addr = value; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); assert(_PyDict_CheckConsistency(mp)); Py_DECREF(old_value); /* which **CAN** re-enter (see issue #22653) */ Py_DECREF(key); return 0;&#125;/* pending state */assert(_PyDict_HasSplitTable(mp));assert(ix == mp-&gt;ma_used);*value_addr = value;mp-&gt;ma_used++;mp-&gt;ma_version_tag = DICT_NEXT_VERSION();assert(_PyDict_CheckConsistency(mp));Py_DECREF(key);return 0; 如上，ix != DKIX_EMPTY 即代表修改值。同时，根据 old_value 可以判断出 表的类型。 PyDict_DelItem前面已经提到 Del 和 Set 有相同的入口 dict_ass_sub。Del 最终实现是靠 PyDict_DelItem()1234567891011121314// dictobject.c/1621int PyDict_DelItem(PyObject *op, PyObject *key)&#123; Py_hash_t hash; assert(key); if (!PyUnicode_CheckExact(key) || (hash = ((PyASCIIObject *) key)-&gt;hash) == -1) &#123; hash = PyObject_Hash(key); if (hash == -1) return -1; &#125; return _PyDict_DelItem_KnownHash(op, key, hash);&#125; 如上，先验证 hash，在调用 _PyDict_DelItem_KnownHash _PyDict_DelItem_KnownHash123456789101112131415161718192021222324252627282930313233int_PyDict_DelItem_KnownHash(PyObject *op, PyObject *key, Py_hash_t hash)&#123; Py_ssize_t hashpos, ix; PyDictObject *mp; PyObject **value_addr; if (!PyDict_Check(op)) &#123; PyErr_BadInternalCall(); return -1; &#125; assert(key); assert(hash != -1); mp = (PyDictObject *)op; ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;value_addr, &amp;hashpos); if (ix == DKIX_ERROR) return -1; if (ix == DKIX_EMPTY || *value_addr == NULL) &#123; _PyErr_SetKeyError(key); return -1; &#125; assert(dk_get_index(mp-&gt;ma_keys, hashpos) == ix); // Split table doesn't allow deletion. Combine it. if (_PyDict_HasSplitTable(mp)) &#123; if (dictresize(mp, DK_SIZE(mp-&gt;ma_keys))) &#123; return -1; &#125; ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;value_addr, &amp;hashpos); assert(ix &gt;= 0); &#125; return delitem_common(mp, hashpos, ix, value_addr);&#125; 如上，_PyDict_DelItem_KnownHash 代码很好理解，根据 key hash 找到相应的 enrty。需要注意的是其中的，Split-table 不允许删除操作，必然要转换为 combined table。 delitem_common1234567891011121314151617181920212223static intdelitem_common(PyDictObject *mp, Py_ssize_t hashpos, Py_ssize_t ix, PyObject **value_addr)&#123; PyObject *old_key, *old_value; PyDictKeyEntry *ep; old_value = *value_addr; assert(old_value != NULL); *value_addr = NULL; mp-&gt;ma_used--; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[ix]; dk_set_index(mp-&gt;ma_keys, hashpos, DKIX_DUMMY); ENSURE_ALLOWS_DELETIONS(mp); old_key = ep-&gt;me_key; ep-&gt;me_key = NULL; Py_DECREF(old_key); Py_DECREF(old_value); assert(_PyDict_CheckConsistency(mp)); return 0;&#125; 如上，代码很简单。。就酱。。 insertion_resize123456// dictobject.c.1099static intinsertion_resize(PyDictObject *mp)&#123; return dictresize(mp, GROWTH_RATE(mp));&#125; 前面，已经提到，在 CRUD 时，有几种情况下会调用 insertion_resize dk_usable &lt;=0 split-table insert key which is not Unicode. split-table insertion order is different from shared key. GROWTH_RATE1#define GROWTH_RATE(d) (((d)-&gt;ma_used*2)+((d)-&gt;ma_keys-&gt;dk_size&gt;&gt;1)) 如上，在调用 dictresize 之前，会先计算一个 GROWTH_RATE。这个东西的作用可以参考链接已失效 123456789101112如果原有的数据量小于原有大小的1/4，那么它也会小于现有大小的1/4，但新的dict缩小了；如果原有的数据量大于原有大小的1/4，那么它也会大于现有大小的1/4，但新的dict扩大了。if used &lt; size/4: used*4 &lt; used*2 + size/4*2 = used*2 + size/2 = newsize used &lt; newsize/4 newsize = used*2 + size/2 &lt; size/4*2 + size/2 = sizeif used &gt; size/4: used*4 &gt; used*2 + size/4*2 = used*2 + size/2 = newsize used &gt; newsize/4 newsize = used*2 + size/2 &gt; size/4*2 + size/2 = size emmm…好吧，看看就好 dictresize123456789101112131415161718192021222324252627282930313233343536373839404142// dictobject.c.1250/* Restructure the table by allocating a new table and reinserting all items again. When entries have been deleted, the new table may actually be smaller than the old one. If a table is split (its keys and hashes are shared, its values are not), then the values are temporarily copied into the table, it is resized as a combined table, then the me_value slots in the old table are NULLed out. After resizing a table is always combined, but can be resplit by make_keys_shared().*/static intdictresize(PyDictObject *mp, Py_ssize_t minsize) ... // 很多很多 /* Allocate a new table. */ // 注：static PyDictKeysObject *new_keys_object(Py_ssize_t size) mp-&gt;ma_keys = new_keys_object(newsize); /* Main loop */ for (i = 0; i &lt; oldkeys-&gt;dk_nentries; i++) &#123; PyDictKeyEntry *ep = &amp;ep0[i]; if (ep-&gt;me_value != NULL) &#123; insertdict_clean(mp, ep-&gt;me_key, ep-&gt;me_hash, ep-&gt;me_value); &#125; &#125; ... // 很多很多&#125;/* Internal routine used by dictresize() to insert an item which is known to be absent from the dict. This routine also assumes that the dict contains no deleted entries. Besides the performance benefit, using insertdict() in dictresize() is dangerous (SF bug #1456209). Note that no refcounts are changed by this routine; if needed, the caller is responsible for incref'ing `key` and `value`. Neither mp-&gt;ma_used nor k-&gt;dk_usable are modified by this routine; the caller must set them correctly*/static voidinsertdict_clean(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value) emm…代码很长，看注释就够了。 dictresize 返回的都是 combined table，跟上文一致 combined split 两者是可以相互转换的 resize 后，表是可以被 扩容或缩小的 insertdict_clean 只干插入的活，不干其他的 只要涉及到 resize ，就涉及到 Malloc memcpy，耗时 耗力]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyDictObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python源码剖析】PyListObject]]></title>
    <url>%2F2018%2F07%2F15%2FPython%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[参考 python.org文档 interface123Another generally useful object type is a list of object pointers.This is a mutable type: the list items can be changed, and items can beadded or removed. Out-of-range indices or non-list objects are ignored. 老套路，开局一段注释： 对象指针列表 可以增删改查 具有索引容错功能 PyListObject123456789101112131415161718// listobject.h.23typedef struct &#123; PyObject_VAR_HEAD PyObject **ob_item; Py_ssize_t allocated;&#125; PyListObject;/* ob_item contains space for 'allocated' elements. The number * currently in use is ob_size. * Invariants: * 0 &lt;= ob_size &lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ 如上，其中的注释很有用，其他信息： **ob_item 明确是指针数组 allocated 标记了容器大小，决定了内存大小 ob_size 标记了元素个数 PyList_Type1234567891011// listobject.c.2624PyTypeObject PyList_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "list", sizeof(PyListObject), 0, (destructor)list_dealloc, /* tp_dealloc */ PyType_GenericAlloc, /* tp_alloc */ PyType_GenericNew, /* tp_new */ (initproc)list_init, /* tp_init */&#125;; 在之前的 PyLong_Type、PyUnicode_Type中，tp_new都是单独定义的函数。而在PyList_Type中，是通用的 PyType_Generic* 函数。下面，我们就来看下他们的逻辑。 PyType_GenericNew1234567891011121314151617181920212223242526272829303132333435363738394041424344// typeobject.c.958PyObject *PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)&#123; return type-&gt;tp_alloc(type, 0);&#125;// typeobject.c.928PyObject * PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)&#123; PyObject *obj; const size_t size = _PyObject_VAR_SIZE(type, nitems+1); /* note that we need to add one, for the sentinel */ if (PyType_IS_GC(type)) obj = _PyObject_GC_Malloc(size); else obj = (PyObject *)PyObject_MALLOC(size); if (obj == NULL)); return PyErr_NoMemory(); memset(obj, '\0', size); if (type-&gt;tp_flags &amp; Py_TPFLAGS_HEAPTYPE) Py_INCREF(type); if (type-&gt;tp_itemsize == 0) (void)PyObject_INIT(obj, type); else (void) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems); if (PyType_IS_GC(type)) _PyObject_GC_TRACK(obj); return obj;&#125;// objimpl.h.141/* Macros trading binary compatibility for speed. See also pymem.h. Note that these macros expect non-NULL object pointers.*/#define PyObject_INIT(op, typeobj) \ ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )#define PyObject_INIT_VAR(op, typeobj, size) \ ( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) ) 如上，具体细节不在深究，能够看出一个轮廓： 根据 type 计算 size 根据 size 调用 MALLOC 调用 INIT 完成初始化 PyList_New123456789PyObject* PyList_New(Py_ssize_t len) Return value: New reference. Return a new list of length len on success, or NULL on failure. Note: If len is greater than zero, the returned list object’s items are set to NULL. Thus you cannot use abstract API functions such as PySequence_SetItem() or expose the object to Python code before setting all items to a real object with PyList_SetItem(). 上面，是来自来自文档的API介绍，其中介绍了创建列表，设置元素的方法。 12345678910111213141516171819202122232425262728293031323334353637383940// listobject.c.104#define PyList_MAXFREELIST 80static PyListObject *free_list[PyList_MAXFREELIST];static int numfree = 0;// listobject.c.140PyObject * PyList_New(Py_ssize_t size)&#123; PyListObject *op; // asert size &gt;= 0 if (size &lt; 0) &#123; PyErr_BadInternalCall(); return NULL; &#125; // 尝试共享 list 对象指针 if (numfree) &#123; numfree--; op = free_list[numfree]; _Py_NewReference((PyObject *)op); &#125; else &#123; op = PyObject_GC_New(PyListObject, &amp;PyList_Type); if (op == NULL) return NULL; &#125; // 获取真实数据地址 if (size &lt;= 0) op-&gt;ob_item = NULL; else &#123; op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); &#125; // 赋初值 Py_SIZE(op) = size; op-&gt;allocated = size; _PyObject_GC_TRACK(op); return (PyObject *) op;&#125; 如上，从中我们可以看到，一个数组 free_list，很容易联想到共享机制。通过 numfree 与 free_list 的配合，实现了列表的共享，却又不同于之前谈到的整数小对象池。此处共享的是对象的指针，但真实数据的地址是不共享的，这点也很容易明白。 共享机制如上，free_list 与 small_ints 类似，都是提供对象缓冲池，但又不完全一样。 小整数对象 small_ints 是一个数组 [-5, 256] 单字节对象 characters 是一个数组 latin-1 [0 - 255] UnicodeObject interned 是一个弱引用的对象字典 ListObject free_list 是一个数组，存放着80个销毁的对象 list_dealloc12345678910111213141516171819// Objects/listobject.c/313行static void list_dealloc(PyListObject *op)&#123; Py_ssize_t i; PyObject_GC_UnTrack(op); Py_TRASHCAN_SAFE_BEGIN(op) if (op-&gt;ob_item != NULL) &#123; i = Py_SIZE(op); while (--i &gt;= 0) &#123; Py_XDECREF(op-&gt;ob_item[i]); &#125; PyMem_FREE(op-&gt;ob_item); &#125; if (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op)) free_list[numfree++] = op; else Py_TYPE(op)-&gt;tp_free((PyObject *)op); Py_TRASHCAN_SAFE_END(op)&#125; 如上，PyList_Type 中定义了 tp_dealloc 为 list_dealloc，在代码中可以看见： 对元素进行循环处理：减引用 对 ob_item 指针进行释放 尝试加入缓冲池 free_list CRUD在 PyList_New 中，很明确的指出创建对象后要先调用 PyList_SetItem PyList_SetItem1234567891011121314151617int PyList_SetItem(PyObject *list, Py_ssize_t index, PyObject *item) Set the item at index index in list to item. Return 0 on success or -1 on failure. Note: This function “steals” a reference to item and discards a reference to an item already in the list at the affected position.void PyList_SET_ITEM(PyObject *list, Py_ssize_t i, PyObject *o) Macro form of PyList_SetItem() without error checking. This is normally only used to fill in new lists where there is no previous content. Note: This macro “steals” a reference to item, and, unlike PyList_SetItem(), does not discard a reference to any item that is being replaced; any reference in list at position i will be leaked. 文档中，指出设置元素的方式，并且指明引用计数的处理原则。 1234567891011121314151617181920212223242526272829303132333435#define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))// listobject.c.218int PyList_SetItem(PyObject *op, Py_ssize_t i, PyObject *newitem)&#123; PyObject **p; // op 类型检查 if (!PyList_Check(op)) &#123; Py_XDECREF(newitem); PyErr_BadInternalCall(); return -1; &#125; // 索引值容错 if (i &lt; 0 || i &gt;= Py_SIZE(op)) &#123; Py_XDECREF(newitem); PyErr_SetString(PyExc_IndexError, "list assignment index out of range"); return -1; &#125; // 对象指针引用 p = ((PyListObject *)op) -&gt; ob_item + i; Py_XSETREF(*p, newitem); return 0;&#125;// object.h.882#define Py_XSETREF(op, op2) \ do &#123; \ PyObject *_py_tmp = (PyObject *)(op); \ (op) = (op2); \ Py_XDECREF(_py_tmp); \ &#125; while (0) 如上，对元素进行赋值操作，单纯的进行了对象指针赋值操作，时间复杂度O(1)。 需要注意的是，如上文所述，在指针替换的过程中，只减少了原地址的引用，并未增加 newitem 的引用数。 PyList_GetItem123456789101112PyObject* PyList_GetItem(PyObject *list, Py_ssize_t index) Return value: Borrowed reference. Return the object at position index in the list pointed to by list. The position must be positive, indexing from the end of the list is not supported. If index is out of bounds, return NULL and set an IndexError exception.PyObject* PyList_GET_ITEM(PyObject *list, Py_ssize_t i) Return value: Borrowed reference. Macro form of PyList_GetItem() without error checking. 文档中也指出了获取元素的方式，其中一个是宏实现。 123456789101112131415161718#define PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])// Objects/listobject.c/198行PyObject * PyList_GetItem(PyObject *op, Py_ssize_t i)&#123; // 类型检查(略) if (i &lt; 0 || i &gt;= Py_SIZE(op)) &#123; if (indexerr == NULL) &#123; indexerr = PyUnicode_FromString( "list index out of range"); if (indexerr == NULL) return NULL; &#125; PyErr_SetObject(PyExc_IndexError, indexerr); return NULL; &#125; return ((PyListObject *)op) -&gt; ob_item[i];&#125; 如上，函数PyList_GetItem会进行容错处理。最终按索引进行数组取值，时间复杂度O(1) PyList_Insert1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// listobject.c.272int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem)&#123; // 类型检查(略) return ins1((PyListObject *)op, where, newitem);&#125;// listobject.c.239static int ins1(PyListObject *self, Py_ssize_t where, PyObject *v)&#123; Py_ssize_t i, n = Py_SIZE(self); PyObject **items; // 容错处理 if (v == NULL) &#123; PyErr_BadInternalCall(); return -1; &#125; if (n == PY_SSIZE_T_MAX) &#123; PyErr_SetString(PyExc_OverflowError, "cannot add more objects to list"); return -1; &#125; // !!! 可能调整位置 !!! if (list_resize(self, n+1) &lt; 0) return -1; // 索引正负号处理 if (where &lt; 0) &#123; where += n; if (where &lt; 0) where = 0; &#125; if (where &gt; n) where = n; // 移动元素 items = self-&gt;ob_item; for (i = n; --i &gt;= where; ) items[i+1] = items[i]; // 插入值 Py_INCREF(v); items[where] = v; return 0;&#125; 如上，对数组进行插值大概可以分为几部分，从中可以看出： 索引 where 支持负值，支持大于元素个数的值 调用 list_resize 可能会调整位置 插入值，会产生移动操作。时间复杂度O(n) list_resize1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// listobject.c.25static int list_resize(PyListObject *self, Py_ssize_t newsize)&#123; PyObject **items; size_t new_allocated; Py_ssize_t allocated = self-&gt;allocated; // 如果足够大，就减小 if (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; 1)) &#123; assert(self-&gt;ob_item != NULL || newsize == 0); Py_SIZE(self) = newsize; return 0; &#125; // 计算新的需要 new_allocated = (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6); /* check for integer overflow */ if (new_allocated &gt; SIZE_MAX - newsize) &#123; PyErr_NoMemory(); return -1; &#125; else &#123; new_allocated += newsize; &#125; if (newsize == 0) new_allocated = 0; items = self-&gt;ob_item; // 调整大小 if (new_allocated &lt;= (SIZE_MAX / sizeof(PyObject *))) PyMem_RESIZE(items, PyObject *, new_allocated); else items = NULL; if (items == NULL) &#123; PyErr_NoMemory(); return -1; &#125; // 赋值 self-&gt;ob_item = items; Py_SIZE(self) = newsize; self-&gt;allocated = new_allocated; return 0;&#125;调用链：if (list_resize(self, n+1) &lt; 0) return -1; 如上，list_resize 接收一个 list对 象指针以及新的size值，成功返回0，失败返回-1。具体分析，见下文的伪代码 12345678910111213141516def list_resize(*self, newsize): allocated = self.allocated if newsize == 0: new_allocated = 0 elif allocated /2 &lt;= newsize &lt;= allocated： self.size = newsize return 0 else: new_allocated = newsize + newsize / 8 + (3 if newsize&lt;9 else 6) PyMem_RESIZE(items, PyObject *, new_allocated); self-&gt;ob_item = items; Py_SIZE(self) = newsize; self-&gt;allocated = new_allocated; return 0; PyMem_RESIZE，调用 PyMem_REALLOC，实现最终的重新分配内存空间。 PyList_Append12345678910111213141516171819202122// Objects/listobject.c/282行static intapp1(PyListObject *self, PyObject *v)&#123; Py_ssize_t n = PyList_GET_SIZE(self); if (list_resize(self, n+1) &lt; 0) return -1; Py_INCREF(v); PyList_SET_ITEM(self, n, v); return 0;&#125;intPyList_Append(PyObject *op, PyObject *newitem)&#123; if (PyList_Check(op) &amp;&amp; (newitem != NULL)) return app1((PyListObject *)op, newitem); PyErr_BadInternalCall(); return -1;&#125; 如上，append -&gt; app1 -&gt; list_resize -&gt; PyList_SET_ITEM若 list_resize 不触发 PyMem_RESIZE()，时间复杂度为 O(1) PyList_GetSlice(list_slice)123456789101112131415161718192021222324252627282930313233343536373839404142// listobject.c.458PyObject *PyList_GetSlice(PyObject *a, Py_ssize_t ilow, Py_ssize_t ihigh)&#123; // 类型检查(略) return list_slice((PyListObject *)a, ilow, ihigh);&#125;// listobject.c.428static PyObject * list_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh)&#123; PyListObject *np; PyObject **src, **dest; Py_ssize_t i, len; // 边界处理 if (ilow &lt; 0) ilow = 0; else if (ilow &gt; Py_SIZE(a)) ilow = Py_SIZE(a); if (ihigh &lt; ilow) ihigh = ilow; else if (ihigh &gt; Py_SIZE(a)) ihigh = Py_SIZE(a); len = ihigh - ilow; // 新对象 np = (PyListObject *) PyList_New(len); if (np == NULL) return NULL; src = a-&gt;ob_item + ilow; dest = np-&gt;ob_item; // 拷贝数据指针 for (i = 0; i &lt; len; i++) &#123; PyObject *v = src[i]; Py_INCREF(v); dest[i] = v; &#125; return (PyObject *)np;&#125; 如上，对List 切片取值。其中需要注意的是，在数据拷贝过程中，拷贝的是指针，实现的是 浅拷贝。 PyList_SetSlice(list_ass_slice)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123intPyList_SetSlice(PyObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)&#123; ... // 类型检查 return list_ass_slice((PyListObject *)a, ilow, ihigh, v);&#125;// listobject.c.569static intlist_ass_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)&#123; PyObject *recycle_on_stack[8]; /* can allocate more if needed */ PyObject **recycle = recycle_on_stack; PyObject **item; PyObject **vitem = NULL; PyObject *v_as_SF = NULL; /* PySequence_Fast(v) */ Py_ssize_t n; /* # of elements in replacement list */ Py_ssize_t norig; /* # of elements in list getting replaced */ Py_ssize_t d; /* Change in size */ Py_ssize_t k; size_t s; int result = -1; /* guilty until proved innocent */#define b ((PyListObject *)v) // v = NULL，不执行操作 if (v == NULL) n = 0; else &#123; if (a == b) &#123; /* Special case "a[i:j] = a" -- copy b first */ v = list_slice(b, 0, Py_SIZE(b)); if (v == NULL) return result; result = list_ass_slice(a, ilow, ihigh, v); Py_DECREF(v); return result; &#125; v_as_SF = PySequence_Fast(v, "can only assign an iterable"); n = PySequence_Fast_GET_SIZE(v_as_SF); vitem = PySequence_Fast_ITEMS(v_as_SF); &#125; // 边界处理（略） ilow = ? ihigh = ? norig = ihigh - ilow; assert(norig&gt;= 0); d = n - norig; // a[:] = [] 清空 if (Py_SIZE(a) + d == 0) &#123; Py_XDECREF(v_as_SF); return list_clear(a); &#125; // 创建临时数据 recycle item = a-&gt;ob_item; /* recycle the items that we are about to remove */ s = norig * sizeof(PyObject *); /* If norig == 0, item might be NULL, in which case we may not memcpy from it. */ if (s) &#123; if (s &gt; sizeof(recycle_on_stack)) &#123; recycle = (PyObject **)PyMem_MALLOC(s); &#125; memcpy(recycle, &amp;item[ilow], s); &#125; // 形如 a[1:10] = [1,2] if (d &lt; 0) &#123; /* Delete -d items */ Py_ssize_t tail; tail = (Py_SIZE(a) - ihigh) * sizeof(PyObject *); // 左移 a[ihigh:]，减少空位 memmove(&amp;item[ihigh+d], &amp;item[ihigh], tail); // 拷贝后，尝试 resieze if (list_resize(a, Py_SIZE(a) + d) &lt; 0) &#123; // 失败后恢复 recycle memmove(&amp;item[ihigh], &amp;item[ihigh+d], tail); memcpy(&amp;item[ilow], recycle, s); goto Error; &#125; item = a-&gt;ob_item; &#125; // 形如 a[0:2] =[1,2,3,4] else if (d &gt; 0) &#123; /* Insert d items */ k = Py_SIZE(a); if (list_resize(a, k+d) &lt; 0) goto Error; item = a-&gt;ob_item; // 右移 a[ihigh:]，腾出位置 memmove(&amp;item[ihigh+d], &amp;item[ihigh], (k - ihigh)*sizeof(PyObject *)); &#125; // 拷贝 v 的值指针到 a for (k = 0; k &lt; n; k++, ilow++) &#123; PyObject *w = vitem[k]; Py_XINCREF(w); // 注意，从 ilow 开始 item[ilow] = w; &#125; // 释放 recycle for (k = norig - 1; k &gt;= 0; --k) Py_XDECREF(recycle[k]); result = 0; Error: if (recycle != recycle_on_stack) PyMem_FREE(recycle); Py_XDECREF(v_as_SF); return result;#undef b&#125; 当执行 a[low:high] = v 时，调用 SetSlice 方法，具体执行逻辑见注释内容。 从源码中，能分析出一些执行结果，伪代码如下：123456789101112131415161718192021222324252627282930/* a[ilow:ihigh] = v if v != NULL. del a[ilow:ihigh] if v == NULL. */&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; del a[1:1]&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]v=NULLn=0ilow = 1ihigh = 1norig = ihigh - ilow = 0d = n - norig = 0不满足 if(d) 中的任何条件，结果就是不做任何操作&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a[1:1] = [1]&gt;&gt;&gt; a[0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9]v!=NULLn=1ilow = 1ihigh = 1norig = ihigh - ilow = 0d = n - norig = 1满足 if(d&gt;0)，右移腾出位置，并插入a[ilow] = 1 listremove12345678910111213141516171819// listobject.c.2193static PyObject * listremove(PyListObject *self, PyObject *v)&#123; Py_ssize_t i; for (i = 0; i &lt; Py_SIZE(self); i++) &#123; int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ); if (cmp &gt; 0) &#123; if (list_ass_slice(self, i, i+1, (PyObject *)NULL) == 0) Py_RETURN_NONE; return NULL; &#125; else if (cmp &lt; 0) return NULL; &#125; PyErr_SetString(PyExc_ValueError, "list.remove(x): x not in list"); return NULL;&#125; 由上，可以看出，删除元素是通过 list_ass_slice 实现： 仅删除第一个遇见的元素，删除一个不在其中的元素，会报错 删除是通过遍历实现，时间复杂度 O(n) 总结PyListObject 也利用了缓冲池机制，只缓冲对象，不缓冲数据。 下面是粗略的时间复杂度( list_resize 不涉及到 移动时)： SetItem - O(1) GetItem - O(1) Append - O(1) Insert - O(n)，对象移动 GetSlice - O(high - low)，创建新对象，拷贝指针 SetSlice - O(n)，对象移动，拷贝指针 Remove - O(n)，遍历，对象移动]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyListObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python源码剖析】PyBytesObject/PyUnicodeObject]]></title>
    <url>%2F2018%2F07%2F15%2FPython%E5%AD%97%E7%AC%A6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[interface众所周知，Python2 中存在 str、bytes、unicode，Python3中只存在 str、bytes，然而却并不表示相同的含义，Python3中的 str 即Python2中的 unicode。 按照 CPython3的文档显示：Sequence Objects下辖 Bytes Objects、Unicode Objects。自PEP393之后，Unicode Type 变成了层次化的结构，用以减少内存占用。 Bytes ObjectsPyBytesObject12345// bytesobject.h.12Type PyBytesObject represents a character string. An extra zero byte isreserved at the end to ensure it is zero-terminated, but a size ispresent so strings with null bytes in them can be represented. Thisis an immutable object type. 同样开局一段注释： 字符串末尾有一个 \0 字符串计数 size 不含 \0 自身是不可变类型 12345678910111213141516// pyport.h.93/* Py_hash_t is the same size as a pointer. */typedef Py_ssize_t Py_hash_t;// bytesobject.h.31typedef struct &#123; PyObject_VAR_HEAD Py_hash_t ob_shash; char ob_sval[1]; /* Invariants: * ob_sval contains space for 'ob_size+1' elements. * ob_sval[ob_size] == 0. * ob_shash is the hash of the string or -1 if not computed yet. */&#125; PyBytesObject; 从源码可以看出： PyBytesObject 是变长对象 用 char 数组存储字符串对象，数组长度默认为 1 数组 ob_sval 含有 ob_size+1 个元素 PyBytesObject 内部有 ob_shash 变量缓存hash值，且 初始值为 -1 PyBytes_Type1234567891011121314151617// bytesobject.c.25#define PyBytesObject_SIZE (offsetof(PyBytesObject, ob_sval) + 1)// bytesobject.c.2837PyTypeObject PyBytes_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "bytes", PyBytesObject_SIZE, // tp_basicsize sizeof(char), // tp_itemsize ... (reprfunc)bytes_repr, /* tp_repr */ &amp;bytes_as_number, /* tp_as_number */ &amp;bytes_as_sequence, /* tp_as_sequence */ &amp;bytes_as_mapping, /* tp_as_mapping */ (hashfunc)bytes_hash, /* tp_hash */ ...&#125;; 恩，不出意外，也是 PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)。 Bytes 共享机制创建对象时，存在跟 small_ints 类似，使用了对象池技术的 characters：123// bytesobject.c.22static PyBytesObject *characters[UCHAR_MAX + 1];static PyBytesObject *nullstring; 当 size==1 时，将尝试从 characters 中获取对象指针。UCHAR_MAX 即 无符号整型最大值 255。 当 size==0 时，将共享使用 同一个 空字符串指针 nullstring。 123456789101112131415161718&gt;&gt;&gt; a = b'a'&gt;&gt;&gt; b = b'a'&gt;&gt;&gt; id(a),id(b)(1618457902176, 1618457902176)&gt;&gt;&gt;&gt;&gt;&gt; a = b'aa'&gt;&gt;&gt; b = b'aa'&gt;&gt;&gt; id(a),id(b)(1618457901016, 1618457902256)&gt;&gt;&gt;&gt;&gt;&gt; c = b'a'&gt;&gt;&gt; id(c)1618457902176&gt;&gt;&gt;&gt;&gt;&gt; d = b''&gt;&gt;&gt; e = b''&gt;&gt;&gt; id(d),id(e)(1618427315824, 1618427315824) PyBytes_FromString12345PyObject* PyBytes_FromString(const char *v)PyObject* PyBytes_FromStringAndSize(const char *v, Py_ssize_t len)PyObject* PyBytes_FromFormat(const char *format, ...)PyObject* PyBytes_FromFormatV(const char *format, va_list vargs)PyObject* PyBytes_FromObject(PyObject *o) 同样，CPython定义了很多创建 BytesObejct 的方法，下面也只看其中一种。 123456789101112131415161718192021222324252627282930313233343536// bytesobject.c.132/* For PyBytes_FromString(), the parameter `str' points to a null-terminated string containing exactly `size' bytes.*/PyObject * PyBytes_FromString(const char *str)&#123; size_t size; PyBytesObject *op; assert(str != NULL); size = strlen(str); if (size == 0 &amp;&amp; (op = nullstring) != NULL) &#123; Py_INCREF(op); return (PyObject *)op; &#125; if (size == 1 &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != NULL) &#123; Py_INCREF(op); return (PyObject *)op; &#125; /* Inline PyObject_NewVar */ op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size); (void)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size); // PY_TYPE(op) = PyBytes_Type op-&gt;ob_shash = -1; memcpy(op-&gt;ob_sval, str, size+1); /* share short strings */ if (size == 0) &#123; nullstring = op; Py_INCREF(op); &#125; else if (size == 1) &#123; characters[*str &amp; UCHAR_MAX] = op; Py_INCREF(op); &#125; return (PyObject *) op;&#125; 从上面的源码可以看出，PyBytes_FromString 大概分为4部分： 计算 字符串长度 strlen(str) 处理 空字符串 size == 0，尝试获取全局变量 nullstring 处理 单字符串 size == 1，尝试获取共享对象 characters 申请空间、创建对象、拷贝内存、返回结果 需要注意的是： PyObject_MALLOC 申请空间大小为 PyBytesObject_SIZE + size，是一个确定的不能再次改变的值 memcpy(op-&gt;ob_sval, str, size+1)， size+1 表明把 字符数组的 ‘\0’也存入了 op_ob_sval，与前文 相对应 op-&gt;ob_shash = -1，hash 缓冲值，赋值-1，与前文相对应 共享数组 characters ，是在对象的不断创建中，逐渐填满 Unicode ObjectsPyUnicodeObject1234567891011121314151617181920212223242526272829/* There are 4 forms of Unicode strings: - compact ascii: * structure = PyASCIIObject * kind = PyUnicode_1BYTE_KIND * 仅 ASCII 字符，7bit * throw PyUnicode_New - compact: * structure = PyCompactUnicodeObject * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * 仅 latin1 且 Non-ASCII 字符，&gt;=8bit * throw PyUnicode_New - legacy string, not ready: * structure = PyUnicodeObject * kind = PyUnicode_WCHAR_KIND * PyUnicode_FromUnicode(NULL, len); - legacy string, ready: * structure = PyUnicodeObject structure * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * PyUnicode_FromUnicode(NULL, len); // compact 与 legacy 的显著区别： Compact strings use only one memory block (structure + characters), whereas legacy strings use one block for the structure and one block for characters.*/ 同样开篇一段注释，详细内容可以看PEP393，之所以弄得这么复杂，就是为了权衡通用性与空间利用率。下面还是来看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// unicodeobject.h.197/* ASCII-only strings created through PyUnicode_New; utf8_length == wstr_length == length; the utf8 pointer == data pointer == wstr */typedef struct &#123; PyObject_HEAD Py_ssize_t length; /* 码位(code points) */ Py_hash_t hash; /* Hash value; -1 if not set */ struct &#123; unsigned int interned:2; // 共享机制 unsigned int kind:3; unsigned int compact:1; unsigned int ascii:1; unsigned int ready:1;/ unsigned int :24; &#125; state; wchar_t *wstr; /* 真实字符串 (null-terminated) */&#125; PyASCIIObject;/* Non-ASCII strings allocated through PyUnicode_New; the data immediately follow the structure. */typedef struct &#123; PyASCIIObject _base; Py_ssize_t utf8_length; /* Number of bytes in utf8, excluding the terminating \0. */ char *utf8; /* UTF-8 representation (null-terminated) */ Py_ssize_t wstr_length; /* Number of code points in wstr, possible * surrogates count as two code points. */&#125; PyCompactUnicodeObject;/* Strings allocated through PyUnicode_FromUnicode(NULL, len); The actual string data is initially in the wstr block; and copied into the data block using _PyUnicode_Ready. */typedef struct &#123; PyCompactUnicodeObject _base; union &#123; void *any; Py_UCS1 *latin1; Py_UCS2 *ucs2; Py_UCS4 *ucs4; &#125; data; /* Canonical, smallest-form Unicode buffer */&#125; PyUnicodeObject; 如上，定义了3种Objec结构体，具体功能及创建方式，见注释内容。 PyUnicode_Type123456789101112131415161718// unicodeobject.c.15170PyTypeObject PyUnicode_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "str", /* tp_name */ sizeof(PyUnicodeObject), /* tp_size */ 0, /* tp_itemsize */ /* Slots */ (destructor)unicode_dealloc, /* tp_dealloc */ ... unicode_repr, /* tp_repr */ &amp;unicode_as_number, /* tp_as_number */ &amp;unicode_as_sequence, /* tp_as_sequence */ &amp;unicode_as_mapping, /* tp_as_mapping */ (hashfunc) unicode_hash, /* tp_hash*/ ... unicode_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; 可见，PyUnicode_Type 就是 Python3 中的 str。 创建对象与 PyBytesObject 类似，PyUnicodeObject 也存在好几种创建方式，详见python.org。由于存在多种 Unicode OBject，各自的创建方式还不一样，下面分开查看。 PyUnicode_New12345678910111213141516171819202122232425262728293031// unicodeobject.c.1220PyObject * PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)&#123; PyObject *obj; PyCompactUnicodeObject *unicode; void *data; enum PyUnicode_Kind kind; int is_sharing, is_ascii; Py_ssize_t char_size; Py_ssize_t struct_size; ... /* 判断 获取变量的值 */ obj = (PyObject *) PyObject_MALLOC(struct_size + (size + 1) * char_size); obj = PyObject_INIT(obj, &amp;PyUnicode_Type); unicode = (PyCompactUnicodeObject *)obj; _PyUnicode_LENGTH(unicode) = size; _PyUnicode_HASH(unicode) = -1; _PyUnicode_STATE(unicode).interned = 0; _PyUnicode_STATE(unicode).kind = kind; _PyUnicode_STATE(unicode).compact = 1; _PyUnicode_STATE(unicode).ready = 1; _PyUnicode_STATE(unicode).ascii = is_ascii; ... /* 根据变量值, 赋值 unicode-&gt;utf8 = ? unicode-&gt;utf8_length = ? _PyUnicode_WSTR_LENGTH(unicode) = ? _PyUnicode_WSTR(unicode) = ? */ return obj;&#125; PyUnicode_New 是创建compact string的方式，代码很长，多数都是在容错处理。最终 MALLOC，然后赋初值，return。那么，问题来了，难道 Unicode Object 没有共享机制？ PyUnicode_FromUnicode12345678910111213141516171819202122232425// unicodeobject.c.1993PyObject * PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)&#123; PyObject *unicode; Py_UCS4 maxchar = 0; Py_ssize_t num_surrogates; if (u == NULL) return (PyObject*)_PyUnicode_New(size); /* 宏套宏，最终实现共享 unicode_empty=PyUnicode_New(0, 0); */ if (size == 0) _Py_RETURN_UNICODE_EMPTY(); /* 共享 Single character*/ if (size == 1 &amp;&amp; (Py_UCS4)*u &lt; 256) return get_latin1_char((unsigned char)*u); /* 创建新 not single 对象 */ unicode = PyUnicode_New(size - num_surrogates, maxchar); switch (PyUnicode_KIND(unicode)) &#123; /* case 不同 kind 执行执行相应的转换*/ &#125; return unicode_result(unicode);&#125; 如上，原始代码很长，上面只截取了相对重要的部分。好高兴，终于看到 Unicode 共享机制的苗头了，不过还得一个一个来看。 _PyUnicode_New12345678910111213141516171819202122232425262728293031323334353637383940414243// unicodeobject.c.1067static PyUnicodeObject * _PyUnicode_New(Py_ssize_t length)&#123; PyUnicodeObject *unicode; size_t new_size; /* 共享 empty strings */ if (length == 0 &amp;&amp; unicode_empty != NULL) &#123; Py_INCREF(unicode_empty); return (PyUnicodeObject*)unicode_empty; &#125; /* 容错代码(略)：length 不能过大，也不能 &lt; 0 */ // 创建对象 unicode = PyObject_New(PyUnicodeObject, &amp;PyUnicode_Type); new_size = sizeof(Py_UNICODE) * ((size_t)length + 1); // 赋初值 _PyUnicode_WSTR_LENGTH(unicode) = length; _PyUnicode_HASH(unicode) = -1; _PyUnicode_STATE(unicode).interned = 0; _PyUnicode_STATE(unicode).kind = 0; _PyUnicode_STATE(unicode).compact = 0; _PyUnicode_STATE(unicode).ready = 0; _PyUnicode_STATE(unicode).ascii = 0; _PyUnicode_DATA_ANY(unicode) = NULL; _PyUnicode_LENGTH(unicode) = 0; _PyUnicode_UTF8(unicode) = NULL; _PyUnicode_UTF8_LENGTH(unicode) = 0; // 真实数据 _PyUnicode_WSTR(unicode) = (Py_UNICODE*) PyObject_MALLOC(new_size); // 讨巧，只处理数组两端 _PyUnicode_WSTR(unicode)[0] = 0; _PyUnicode_WSTR(unicode)[length] = 0; return unicode;&#125;// 调用链：if (u == NULL) return (PyObject*)_PyUnicode_New(size); 源码依然很长，从整理后的代码可以看出，_PyUnicode_New 使用场景是：知道字符串长度，但不知道字符串的具体内容。只创建了内存空间，真实数据 ‘都是0’ 。 get_latin1_char(latin-1共享机制)123456789101112131415161718static PyObject* get_latin1_char(unsigned char ch)&#123; PyObject *unicode = unicode_latin1[ch]; if (!unicode) &#123; unicode = PyUnicode_New(1, ch); if (!unicode) return NULL; PyUnicode_1BYTE_DATA(unicode)[0] = ch; assert(_PyUnicode_CheckConsistency(unicode, 1)); unicode_latin1[ch] = unicode; &#125; Py_INCREF(unicode); return unicode;&#125;// 调用链：if (size == 1 &amp;&amp; (Py_UCS4)*u &lt; 256) return get_latin1_char((unsigned char)*u); 在上面的代码中，看到了熟悉的套路，一个数组unicode_latin1。1234// unicodeobject.c.213/* Single character Unicode strings in the Latin-1 range are being shared as well. */static PyObject *unicode_latin1[256] = &#123;NULL&#125;; 可见unicode_latin1数组，是一开始就创建，但并未填充数据，这就是单 unicode 的共享机制。 unicode_result123456789101112131415161718192021222324252627282930313233343536// unicodeobject.c.548static PyObject* unicode_result(PyObject *unicode)&#123; if (PyUnicode_IS_READY(unicode)) return unicode_result_ready(unicode); else return unicode_result_wchar(unicode);&#125;static PyObject* unicode_result_ready(PyObject *unicode)&#123; Py_ssize_t length; length = PyUnicode_GET_LENGTH(unicode); if (length == 0) &#123; // 共享 unicode_empty return unicode_empty; &#125; if (length == 1) &#123; void *data = PyUnicode_DATA(unicode); int kind = PyUnicode_KIND(unicode); Py_UCS4 ch = PyUnicode_READ(kind, data, 0); if (ch &lt; 256) &#123; // 共享 latin1_char return unicode; &#125; &#125; return unicode;&#125;// 调用链：/* 创建新 not single 对象 PyUnicode_New 中赋值 unicode.ready = 1; */unicode = PyUnicode_New(size - num_surrogates, maxchar);return unicode_result(unicode); 从上面的代码来看，似乎 unicode_result 对 PyUnicode_New 来说，纯粹是多余的。 从整个PyUnicode_FromUnicode来看，只是针对单latin-1字符，进行了共享。那就不能解释下面的代码：123456789101112&gt;&gt;&gt; a = 'abcde'&gt;&gt;&gt; b = 'abcde'&gt;&gt;&gt; id(a), id(b),id(a)==id(b)(1605538588408, 1605538588408, True)&gt;&gt;&gt; del a&gt;&gt;&gt; del b&gt;&gt;&gt; a = 'abcde'&gt;&gt;&gt; id(a)1605538115744&gt;&gt;&gt; b = 'abcde'&gt;&gt;&gt; id(a) == id(b)True Unicode 共享机制1234// unicodeobject.h.412#define SSTATE_NOT_INTERNED 0 // 未共享#define SSTATE_INTERNED_MORTAL 1 // 共享，不增加引用计数#define SSTATE_INTERNED_IMMORTAL 2 // 永久，不会被销毁 在上文的PyUnicode_New、_PyUnicode_New中，都进行了 unicode.interned = 0 赋值操作。在源码中发现 0 对应着不共享。 同时在 unicodeobject.c源码中，发现 4个可疑函数：1234void PyUnicode_InternInPlace(PyObject **p)void PyUnicode_InternImmortal(PyObject **p)PyObject * PyUnicode_InternFromString(const char *cp)void _Py_ReleaseInternedUnicodeStrings(void) 在 CPython 的其他源码中，大量存在类似true_str = PyUnicode_InternFromString(&quot;True&quot;)的代码，而PyUnicode_InternFromString内部又调用PyUnicode_InternInPlace。 PyUnicode_InternInPlace123456789101112131415161718192021222324252627282930313233343536373839// unicodeobject.c.174/* 注意，interned 不会影响 deallocation*/static PyObject *interned = NULL;static PyObject *unicode_empty = NULL;// unicodeobject.c.15278void PyUnicode_InternInPlace(PyObject **p)&#123; PyObject *s = *p; PyObject *t; // 类型检查，对子类 不共享 if (s == NULL || !PyUnicode_Check(s)) return; /* If it's a subclass, we don't really know what putting it in the interned dict might do. */ if (!PyUnicode_CheckExact(s)) return; if (PyUnicode_CHECK_INTERNED(s)) return; // 初始化 interned 字典 if (interned == NULL) &#123; interned = PyDict_New(); &#125; Py_ALLOW_RECURSION // ceval.h.113，保存线程 recursion_critical t = PyDict_SetDefault(interned, s, s); Py_END_ALLOW_RECURSION // 恢复 recursion_critical // 之前不存在 if (t != s) &#123; Py_INCREF(t); Py_SETREF(*p, t); return; &#125; // 已经存在 Py_REFCNT(s) -= 2; // k,v 各一次 _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL; // == 1&#125; 可以发现： 共享前会进行类型检查，共享历史检查 共享是用 interned 这个字典对象实现 PyDict_SetDefault 返回的是字典中对象的指针 若 t != s 即，字典中已经存在该值，对t 减引用，修改 *p 指向，返回 若 t ==s 即，字典中之前不存在，那么 放入字典，并设置 s.interned = 1 interned 字典中的指针，不作为对象的有效引用，因此执行 Py_REFCNT(s) -= 2 问题暂时解决了，利用 interned 字典+PyUnicode_Intern*实现了共享。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyBytesObject</tag>
        <tag>PyUnicodeObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python源码剖析】PyLongObject/整数类型]]></title>
    <url>%2F2018%2F07%2F14%2FPython%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中所指 “前文”，皆指本人博客中【Python源码分析】中的系列文章 参考 《Python源码剖析》，感谢陈儒先生的著作 Python.org-Integer Objects，感谢Python社区的成果共享 PyLongObject在 Python2 中，存在 PyIntObject 和 PyLongObject 两种类型。前者是一个定长对象，后者是一个变长对象。Python3中 只存在后者。在 Python2 的结构体中 定义的是 long ob_ival，而 Python3 中定义的是只有1个元素的数组。1234567891011121314// longobject.h.10typedef struct _longobject PyLongObject;// longintrepr.h.85struct _longobject &#123; PyObject_VAR_HEAD digit ob_digit[1]; // digit 与平台相关，长度不一致&#125;;/* ob_size == 0 -&gt; zero ob_size &lt; 0 -&gt; 负数 PyLong_SHIFT == 30 or 15 value == SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)*/ 由上可以看出，在 Python 中，整形的存储方式，是存储在一个数组中。因此通过控制 PyVarObject 的 ob_size 值，可以表示出非常非常大的数。 PyTypeObject12345678910111213// longobject.c.5431PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "int", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ... &amp;long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ long_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; 可见： int对象的类型对象是 PyLong_Type 从之前的 PyObject 分析也能得出 PyLong_Type的类型对象是 PyType_Type int对象，只支持 as_number，不支持作为序列、映射对象操作 123456789101112131415161718// longobject.c.5393static PyNumberMethods long_as_number = &#123; (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ ... long_float, /*nb_float*/ ...&#125;;// longobject.c.3108static PyObject *long_add(PyLongObject *a, PyLongObject *b)&#123; PyLongObject *z; .. // 检查，计算，返回 return (PyObject *)z;&#125; long_as_number 是前文所述 PyNumberMethods 函数簇的 一个结构体实例，初始化了大量方法。如上面的 long_add 操作，创建并返回一个新的 PyObject。 对象池 small_ints1234567891011121314151617181920// longobject.c.12#define NSMALLPOSINTS 257#define NSMALLNEGINTS 5static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];// longobject.c.5514int _PyLong_Init(void)&#123; int ival, size; PyLongObject *v = small_ints; for (ival = -NSMALLNEGINTS; ival &lt; NSMALLPOSINTS; ival++, v++) &#123; size = (ival &lt; 0) ? -1 : ((ival == 0) ? 0 : 1); (void)PyObject_INIT(v, &amp;PyLong_Type); // Py_TYPE(op) = tp; Py_SIZE(v) = size; v-&gt;ob_digit[0] = (digit)abs(ival); &#125; return 1;&#125; 如上，当 Python 初始化时，_PyLong_Init 被调用，然后会 初始化 small_ints数组，作为小整数对象池来共享使用。 前面也提到了 _longobject 结构体中 定义的是 digit ob_digit[1]，从源码中可以发现： small_ints数组长度，默认[-5, 256] size 与 值的关系：小于0 or 等于0 or 大于0 小整数共享123456789101112131415// longobject.c.51#define CHECK_SMALL_INT(ival) \ do if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123; \ return get_small_int((sdigit)ival); \ &#125; while(0)// longobject.c.37static PyObject * get_small_int(sdigit ival)&#123; PyObject *v; assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS); v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS]; Py_INCREF(v); return v;&#125; 如上，通过宏 CHECK_SMALL_INT，可以共享小整数。返回增加引用计数，并且返回指针。 创建对象1234567891011PyObject* PyLong_FromLong(long v)PyObject* PyLong_FromUnsignedLong(unsigned long v)PyObject* PyLong_FromSsize_t(Py_ssize_t v)PyObject* PyLong_FromSize_t(size_t v)PyObject* PyLong_FromLongLong(long long v)PyObject* PyLong_FromUnsignedLongLong(unsigned long long v)PyObject* PyLong_FromDouble(double v)PyObject* PyLong_FromString(const char *str, char **pend, int base)PyObject* PyLong_FromUnicode(Py_UNICODE *u, Py_ssize_t length, int base)PyObject* PyLong_FromUnicodeObject(PyObject *u, int base)PyObject* PyLong_FromVoidPtr(void *p) 在 CPython3.6.6 中，提供了大量创建 PyLongObject 的方法。下面，我们将查看其中一个。 PyLong_FromLong123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051PyObject * PyLong_FromLong(long ival)&#123; PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so &gt;&gt; doesn't propagate sign bit */ int ndigits = 0; int sign; CHECK_SMALL_INT(ival); // 宏，尝试小整数共享 // 处理得到 abs_ival(unsigned long) if (ival &lt; 0) &#123; /* negate: can't write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; &#125; else &#123; abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; &#125; /* 处理 single-digit ints */ if (!(abs_ival &gt;&gt; PyLong_SHIFT)) &#123; v = _PyLong_New(1); if (v) &#123; Py_SIZE(v) = sign; v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST(abs_ival, unsigned long, digit); // pyport.h.304: #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE) &#125; return (PyObject*)v; &#125; /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) &#123; ++ndigits; t &gt;&gt;= PyLong_SHIFT; &#125; v = _PyLong_New(ndigits); if (v != NULL) &#123; digit *p = v-&gt;ob_digit; Py_SIZE(v) = ndigits*sign; t = abs_ival; while (t) &#123; *p++ = Py_SAFE_DOWNCAST(t &amp; PyLong_MASK, unsigned long, digit); t &gt;&gt;= PyLong_SHIFT; &#125; &#125; return (PyObject *)v;&#125; 如上，创建一个 int 对象，主要有以下几个步骤： 尝试从对象池中获取 处理获取 abs_value 处理 single-digit 循环处理 Larger numbers 代码很简单，下面只看一下 _PyLong_New 具体逻辑。 _PyLong_New12345678910111213141516// longobject.c.179#define MAX_LONG_DIGITS \ ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit))PyLongObject * _PyLong_New(Py_ssize_t size)&#123; PyLongObject *result; if (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) &#123; PyErr_SetString(PyExc_OverflowError, "too many digits in integer"); return NULL; &#125; result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size*sizeof(digit)); return (PyLongObject*)PyObject_INIT_VAR(result, &amp;PyLong_Type, size);&#125; 从代码可以看出，能够表示的最大整数是跟堆内存相关的，几乎可以表示无穷大的数了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>源码</tag>
        <tag>PyLongObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python源码剖析】PyObject/PyObjectType]]></title>
    <url>%2F2018%2F07%2F14%2FPyObject%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中主要参考陈儒先生的著作，在正文中将不再重复声明 参考资料 《Python源码剖析》，感谢陈儒先生的著作 python.org，感谢Python社区的成果共享 Interface 123456789101112131415161718192021222324252627# object.h.8/* Object and type object interface */Objects are structures allocated on the heap.Objects are never allocated statically or on the stack;An object has a &apos;reference count&apos; that is increased or decreased when apointer to the object is copied or deleted;when the reference count reaches zero there are no references to the object leftand it can be removed from the heap.An object has a &apos;type&apos; that determines what it represents and what kindof data it contains. An object&apos;s type is fixed when it is created.Types themselves are represented as objects; an object contains apointer to the corresponding type object. The type itself has a typepointer pointing to the object representing the type &apos;type&apos;, whichcontains a pointer to itself!).once allocated an object keeps the same size and address.Objects that must hold variable-size data can contain pointers tovariable-size parts of the object.Objects are always accessed through pointers of the type &apos;PyObject *&apos;.The type &apos;PyObject&apos; is a structure that only contains the reference countand the type pointer.A standard interface exists for objects that contain an array of itemswhose size is determined when the object is allocated. 开篇一段注释，从注释中能提取到很多要点： 对象堆分配、从不栈分配 垃圾回收之引用计数 对象、类型对象、type 容器对象可变依据：持有指针 基石对象 PyObject 与类型转换 PyObject123456789101112// object.h.98typedef struct _object &#123; // ifdef Py_TRACE_REFS，定义双向链表存储所有堆上存活对象指针 _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; # 引用计数 struct _typeobject *ob_type; # 类型对象指针&#125; PyObject;typedef struct &#123; PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part，作 int 理解*/&#125; PyVarObject; 在 Python 中，实际上没有任何东西被声明为 PyObject，但所有对象都可以通过 PyObject 进行引用。类似的还有，指向容器的 PyVarObject 。 PyObject 结构体中包含： 指向类型对象 _typeobject 的指针 ob_type 用于垃圾回收的引用计数 ob_refcnt 对于容器对象，PyObject_VAR_HEAD 用 ob_size 代表元素个数。 PyTypeObject1234567891011121314151617181920212223242526272829// include.h.346typedef struct _typeobject &#123; PyObject_VAR_HEAD // #define PyObject_VAR_HEAD PyVarObject ob_base; const char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; /* Method suites for standard classes */ PyNumberMethods *tp_as_number; PySequenceMethods *tp_as_sequence; PyMappingMethods *tp_as_mapping; /* More standard operations (here for binary compatibility) */ /* Functions to access object as input/output buffer */ /* Flags to define presence of optional/expanded features */ /* Documentation string */ /* call function for all accessible objects */ /* delete references to contained objects */ /* weak reference enabler */ /* Iterators */ getiterfunc tp_iter; iternextfunc tp_iternext; /* Attribute descriptor and subclassing stuff */ struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members;&#125; PyTypeObject; 创建对象之前，必须知道申请的内存空间大小，而这些元信息就存储在对象的类型对象中。含有头域PyObject_VAR_HEAD，表明类型对象本身是 可变长对象。结构体内存储大量信息，主要包括： 常规信息：类型名、Doc、tp_itemsize、tp_basicsize等 常规方法指针：tp_new、tp_init、tp_free等 函数簇：PyNumberMethods、PySequenceMethods等 123456// object.h.301typedef struct &#123; lenfunc mp_length; binaryfunc mp_subscript; objobjargproc mp_ass_subscript;&#125; PyMappingMethods; 在函数簇 PyMappingMethods 中，定义了支持映射的对象应该支持的操作。反过来说，一旦定义了 其中的方法，那么该对象就支持该方法。正因为 PyTypeObject 中同时定义了三种函数簇，所以才可以实现鸭子类型。 PyType_Type前面说过，PyVarObject -&gt; PyObject -&gt; PyTypeObject，但 PyTypeObject 内部又存在 PyVarObject。那么，这个内部的 VarObject 的 type 又是什么？此处先来看下 a = int(10) == 整型对象 a.ob_type == PyLong_Type PyLong_Type.ob_type == PyType_Type PyType_Type.ob_type == PyType_Type 123456789101112131415161718192021// object.h.85#define PyObject_HEAD_INIT(type) &#123; 1, type &#125;,#define PyVarObject_HEAD_INIT(type, size) &#123; PyObject_HEAD_INIT(type) size &#125;,// typeobject.c.3383PyTypeObject PyType_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) /* ob_base = &#123;ob_refcnt=1, *ob_type=PyType_Type&#125; ob_size = 0 */ "type", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ ... type_doc, /* tp_doc */ ... type_init, /* tp_init */ type_new, /* tp_new */ ...&#125;; 如上，可以看见 tp_name == ‘type’，即 Python 中 type 的类型对象就是 PyType_Type。第一句，&amp;PyType_Type 印证了 type(type)==type，形成自旋。 对于内建对象，Python 中有定义好的结构体，如 PyLongObject-&gt;PyLong_Type。而对于用户创建的类，就必须动态创建 type 对象。我们知道，创建类可以通过 type() 的方式生成，最终将调用 PyType_Type.type_new()。 PyBaseObject_Type1234567891011// typeobject.c.4535PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "object", /* tp_name */ sizeof(PyObject), /* tp_basicsize */ object_methods, /* tp_methods */ object_init, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ object_new, /* tp_new */&#125;; 从上可以看出，object的类型对象就是PyBaseObject_Type。第一句，&amp;PyType_Type 印证了 type(object)==type，即 object 的类型对象，的类型对象是 PyType_Type。 object VS type这里要搞清楚的是： 对象，是通过 PyObject 结构体定义的，必须包含 ob_refcnt、ob_type 类型，PyBaseObject_Type、PyType_Type，本身也是可变对象 PyVarObject 普通对象的类型指针，ob_type，指向的是 类型对象：PyBaseObject_Type、PyType_Type 而 PyBaseObject_Type 本身也是对象，也具有 ob_type，指向的是 PyType_Type 最终 PyType_Type 也是对象，其 ob_type，指向的是 自身 123456789101112PyTypeObject PyList_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;list&quot;,&#125;PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;int&quot;,&#125;PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;object&quot;,&#125; 层次结构： 基石，PyObject，一切皆对象 最顶端的是 type，这也正是 type 被称为 metaclass 的原因。 内置对象 list/int/object等，其类型对象都是指向 type。 实例对象 int(1)，其类型对象是 PyLong_Type。 假设： 没有 1，好像可以照常用，只是不能创建 类了 没有 2, 也可以照常用，只是每次需要自己创建 int等基础类型 没有 3，不能实例化了，啥也干不了 容易混淆的是： object，既可以说是实例对象 3，又可以说是 类型对象 2，还可以说成 python对象 0 type，既可以说成实例对象3的类型对象 2，又可以说成元类 1 如果有人问，type 和 object 的关系，就得先问清楚他说的 type和object 指哪一个层面！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开通啦]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在时间、成本、道德约束等各种抉择下，最终还是选择了github.io。嗯，安心写博客。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>起风了</tag>
      </tags>
  </entry>
</search>
