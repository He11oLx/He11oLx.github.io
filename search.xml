<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Python源码剖析】PyLongObject/整数类型]]></title>
    <url>%2F2018%2F07%2F14%2FPython%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中所指 “前文”，皆指本人博客中【Python源码分析】中的系列文章 参考 《Python源码剖析》，感谢陈儒先生的著作 Python.org-Integer Objects，感谢Python社区的成果共享 PyLongObject在 Python2 中，存在 PyIntObject 和 PyLongObject 两种类型。前者是一个定长对象，后者是一个变长对象。Python3中 只存在后者。在 Python2 的结构体中 定义的是 long ob_ival，而 Python3 中定义的是只有1个元素的数组。1234567891011121314// longobject.h.10ftypedef struct _longobject PyLongObject;// longintrepr.h.85struct _longobject &#123; PyObject_VAR_HEAD digit ob_digit[1]; // digit 与平台相关，长度不一致&#125;;/* ob_size == 0 -&gt; zero ob_size &lt; 0 -&gt; 负数 PyLong_SHIFT == 30 or 15 value == SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)*/ 由上可以看出，在 Python 中，整形的存储方式，是存储在一个数组中。因此通过控制 PyVarObject 的 ob_size 值，可以表示出非常非常大的数。 PyTypeObject12345678910111213// longobject.c.5431PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "int", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ... &amp;long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ long_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; 可见： int对象的类型对象是 PyLong_Type 从之前的 PyObject 分析也能得出 PyLong_Type的类型对象是 PyType_Type int对象，只支持 as_number，不支持作为序列、映射对象操作 123456789101112131415161718// longobject.c.5393static PyNumberMethods long_as_number = &#123; (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ ... long_float, /*nb_float*/ ...&#125;;// longobject.c.3108static PyObject *long_add(PyLongObject *a, PyLongObject *b)&#123; PyLongObject *z; .. // 检查，计算，返回 return (PyObject *)z;&#125; long_as_number 是前文所述 PyNumberMethods 函数簇的 一个结构体实例，初始化了大量方法。如上面的 long_add 操作，创建并返回一个新的 PyObject。 对象池 small_ints1234567891011121314151617181920// longobject.c.12#define NSMALLPOSINTS 257#define NSMALLNEGINTS 5static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];// longobject.c.5514int _PyLong_Init(void)&#123; int ival, size; PyLongObject *v = small_ints; for (ival = -NSMALLNEGINTS; ival &lt; NSMALLPOSINTS; ival++, v++) &#123; size = (ival &lt; 0) ? -1 : ((ival == 0) ? 0 : 1); (void)PyObject_INIT(v, &amp;PyLong_Type); // Py_TYPE(op) = tp; Py_SIZE(v) = size; v-&gt;ob_digit[0] = (digit)abs(ival); &#125; return 1;&#125; 如上，当 Python 初始化时，_PyLong_Init 被调用，然后会 初始化 small_ints数组，作为小整数对象池来共享使用。 前面也提到了 _longobject 结构体中 定义的是 digit ob_digit[1]，从源码中可以发现： small_ints数组长度，默认[-5, 256] size 与 值的关系：小于0 or 等于0 or 大于0 小整数共享123456789101112131415// longobject.c.51#define CHECK_SMALL_INT(ival) \ do if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123; \ return get_small_int((sdigit)ival); \ &#125; while(0)// longobject.c.37static PyObject * get_small_int(sdigit ival)&#123; PyObject *v; assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS); v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS]; Py_INCREF(v); return v;&#125; 如上，通过宏 CHECK_SMALL_INT，可以共享小整数。返回增加引用计数，并且返回指针。 创建对象1234567891011PyObject* PyLong_FromLong(long v)PyObject* PyLong_FromUnsignedLong(unsigned long v)PyObject* PyLong_FromSsize_t(Py_ssize_t v)PyObject* PyLong_FromSize_t(size_t v)PyObject* PyLong_FromLongLong(long long v)PyObject* PyLong_FromUnsignedLongLong(unsigned long long v)PyObject* PyLong_FromDouble(double v)PyObject* PyLong_FromString(const char *str, char **pend, int base)PyObject* PyLong_FromUnicode(Py_UNICODE *u, Py_ssize_t length, int base)PyObject* PyLong_FromUnicodeObject(PyObject *u, int base)PyObject* PyLong_FromVoidPtr(void *p) 在 CPython3.6.6 中，提供了大量创建 PyLongObject 的方法。下面，我们将查看其中一个。 PyLong_FromLong123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051PyObject * PyLong_FromLong(long ival)&#123; PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so &gt;&gt; doesn't propagate sign bit */ int ndigits = 0; int sign; CHECK_SMALL_INT(ival); // 宏，尝试小整数共享 // 处理得到 abs_ival(unsigned long) if (ival &lt; 0) &#123; /* negate: can't write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; &#125; else &#123; abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; &#125; /* 处理 single-digit ints */ if (!(abs_ival &gt;&gt; PyLong_SHIFT)) &#123; v = _PyLong_New(1); if (v) &#123; Py_SIZE(v) = sign; v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST(abs_ival, unsigned long, digit); // pyport.h.304: #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE) &#125; return (PyObject*)v; &#125; /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) &#123; ++ndigits; t &gt;&gt;= PyLong_SHIFT; &#125; v = _PyLong_New(ndigits); if (v != NULL) &#123; digit *p = v-&gt;ob_digit; Py_SIZE(v) = ndigits*sign; t = abs_ival; while (t) &#123; *p++ = Py_SAFE_DOWNCAST(t &amp; PyLong_MASK, unsigned long, digit); t &gt;&gt;= PyLong_SHIFT; &#125; &#125; return (PyObject *)v;&#125; 如上，创建一个 int 对象，主要有以下几个步骤： 尝试从对象池中获取 处理获取 abs_value 处理 single-digit 循环处理 Larger numbers 代码很简单，下面只看一下 _PyLong_New 具体逻辑。 _PyLong_New12345678910111213141516// longobject.c.179#define MAX_LONG_DIGITS \ ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit))PyLongObject * _PyLong_New(Py_ssize_t size)&#123; PyLongObject *result; if (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) &#123; PyErr_SetString(PyExc_OverflowError, "too many digits in integer"); return NULL; &#125; result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size*sizeof(digit)); return (PyLongObject*)PyObject_INIT_VAR(result, &amp;PyLong_Type, size);&#125; 从代码可以看出，能够表示的最大整数是跟堆内存相关的，几乎可以表示无穷大的数了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>源码</tag>
        <tag>PyLongObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python源码剖析】PyObject/PyObjectType]]></title>
    <url>%2F2018%2F07%2F14%2FPyObject%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中主要参考陈儒先生的著作，在正文中将不再重复声明 参考资料 《Python源码剖析》，感谢陈儒先生的著作 python.org，感谢Python社区的成果共享 Interface 123456789101112131415161718192021222324252627# object.h.8/* Object and type object interface */Objects are structures allocated on the heap.Objects are never allocated statically or on the stack;An object has a &apos;reference count&apos; that is increased or decreased when apointer to the object is copied or deleted;when the reference count reaches zero there are no references to the object leftand it can be removed from the heap.An object has a &apos;type&apos; that determines what it represents and what kindof data it contains. An object&apos;s type is fixed when it is created.Types themselves are represented as objects; an object contains apointer to the corresponding type object. The type itself has a typepointer pointing to the object representing the type &apos;type&apos;, whichcontains a pointer to itself!).once allocated an object keeps the same size and address.Objects that must hold variable-size data can contain pointers tovariable-size parts of the object.Objects are always accessed through pointers of the type &apos;PyObject *&apos;.The type &apos;PyObject&apos; is a structure that only contains the reference countand the type pointer.A standard interface exists for objects that contain an array of itemswhose size is determined when the object is allocated. 开篇一段注释，从注释中能提取到很多要点： 对象堆分配、从不栈分配 垃圾回收之引用计数 对象、类型对象、type 容器对象可变依据：持有指针 基石对象 PyObject 与类型转换 PyObject123456789101112// object.h.98typedef struct _object &#123; // ifdef Py_TRACE_REFS，定义双向链表存储所有堆上存活对象指针 _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; # 引用计数 struct _typeobject *ob_type; # 类型对象指针&#125; PyObject;typedef struct &#123; PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part，作 int 理解*/&#125; PyVarObject; 在 Python 中，实际上没有任何东西被声明为 PyObject，但所有对象都可以通过 PyObject 进行引用。类似的还有，指向容器的 PyVarObject 。 PyObject 结构体中包含： 指向类型对象 _typeobject 的指针 ob_type 用于垃圾回收的引用计数 ob_refcnt 对于容器对象，PyObject_VAR_HEAD 用 ob_size 代表元素个数。 PyTypeObject1234567891011121314151617181920212223242526272829// include.h.346typedef struct _typeobject &#123; PyObject_VAR_HEAD // #define PyObject_VAR_HEAD PyVarObject ob_base; const char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; /* Method suites for standard classes */ PyNumberMethods *tp_as_number; PySequenceMethods *tp_as_sequence; PyMappingMethods *tp_as_mapping; /* More standard operations (here for binary compatibility) */ /* Functions to access object as input/output buffer */ /* Flags to define presence of optional/expanded features */ /* Documentation string */ /* call function for all accessible objects */ /* delete references to contained objects */ /* weak reference enabler */ /* Iterators */ getiterfunc tp_iter; iternextfunc tp_iternext; /* Attribute descriptor and subclassing stuff */ struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members;&#125; PyTypeObject; 创建对象之前，必须知道申请的内存空间大小，而这些元信息就存储在对象的类型对象中。含有头域PyObject_VAR_HEAD，表明类型对象本身是 可变长对象。结构体内存储大量信息，主要包括： 常规信息：类型名、Doc、tp_itemsize、tp_basicsize等 常规方法指针：tp_new、tp_init、tp_free等 函数簇：PyNumberMethods、PySequenceMethods等 123456// object.h.301typedef struct &#123; lenfunc mp_length; binaryfunc mp_subscript; objobjargproc mp_ass_subscript;&#125; PyMappingMethods; 在函数簇 PyMappingMethods 中，定义了支持映射的对象应该支持的操作。反过来说，一旦定义了 其中的方法，那么该对象就支持该方法。正因为 PyTypeObject 中同时定义了三种函数簇，所以才可以实现鸭子类型。 PyType_Type前面说过，PyVarObject -&gt; PyObject -&gt; PyTypeObject，但 PyTypeObject 内部又存在 PyVarObject。那么，这个内部的 VarObject 的 type 又是什么？此处先来看下 a = int(10) == 整型对象 a.ob_type == PyLong_Type PyLong_Type.ob_type == PyType_Type PyType_Type.ob_type == PyType_Type 123456789101112131415161718192021// object.h.85#define PyObject_HEAD_INIT(type) &#123; 1, type &#125;,#define PyVarObject_HEAD_INIT(type, size) &#123; PyObject_HEAD_INIT(type) size &#125;,// typeobject.c.3383PyTypeObject PyType_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) /* ob_base = &#123;ob_refcnt=1, *ob_type=PyType_Type&#125; ob_size = 0 */ "type", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ ... type_doc, /* tp_doc */ ... type_init, /* tp_init */ type_new, /* tp_new */ ...&#125;; 如上，可以看见 tp_name == ‘type’，即 Python 中 type 的类型对象就是 PyType_Type。第一句，&amp;PyType_Type 印证了 type(type)==type，形成自旋。 对于内建对象，Python 中有定义好的结构体，如 PyLongObject-&gt;PyLong_Type。而对于用户创建的类，就必须动态创建 type 对象。我们知道，创建类可以通过 type() 的方式生成，最终将调用 PyType_Type.type_new()。 PyBaseObject_Type1234567891011// typeobject.c.4535PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "object", /* tp_name */ sizeof(PyObject), /* tp_basicsize */ object_methods, /* tp_methods */ object_init, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ object_new, /* tp_new */&#125;; 从上可以看出，object的类型对象就是PyBaseObject_Type。第一句，&amp;PyType_Type 印证了 type(object)==type，即 object 的类型对象，的类型对象是 PyType_Type。 object VS type这里要搞清楚的是： 对象，是通过 PyObject 结构体定义的，必须包含 ob_refcnt、ob_type 类型，PyBaseObject_Type、PyType_Type，本身也是可变对象 PyVarObject 普通对象的类型指针，ob_type，指向的是 类型对象：PyBaseObject_Type、PyType_Type 而 PyBaseObject_Type 本身也是对象，也具有 ob_type，指向的是 PyType_Type 最终 PyType_Type 也是对象，其 ob_type，指向的是 自身 123456789101112PyTypeObject PyList_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;list&quot;,&#125;PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;int&quot;,&#125;PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;object&quot;,&#125; 层次结构： 基石，PyObject，一切皆对象 最顶端的是 type，这也正是 type 被称为 metaclass 的原因。 内置对象 list/int/object等，其类型对象都是指向 type。 实例对象 int(1)，其类型对象是 PyLong_Type。 假设： 没有 1，好像可以照常用，只是不能创建 类了 没有 2, 也可以照常用，只是每次需要自己创建 int等基础类型 没有 3，不能实例化了，啥也干不了 容易混淆的是： object，既可以说是实例对象 3，又可以说是 类型对象 2，还可以说成 python对象 0 type，既可以说成实例对象3的类型对象 2，又可以说成元类 1 如果有人问，type 和 object 的关系，就得先问清楚他说的 type和object 指哪一个层面！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开通啦]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在时间、成本、道德约束等各种抉择下，最终还是选择了github.io。嗯，安心写博客。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>起风了</tag>
      </tags>
  </entry>
</search>
