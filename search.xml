<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】Python 函数机制]]></title>
    <url>%2F2018%2F07%2F21%2F1.9.Python%20%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[参考 python.org 前言在前面我们已经知道 Python 通过PyInterpreterState 对象模拟进程的状态信息，通过 PyThreadState 对象模拟线程的状态信息，通过PyFrameObject 模拟函数调用时的栈帧信息。FrameObject 通过 f_back 指针，形成函数调用的链式结构。那么要实现函数间的调用，就必然存在多个 Frame。 PyFunctionObject12345678910111213141516// funcobject.h.21typedef struct &#123; PyObject_HEAD PyObject *func_code; /* A code object, the __code__ attribute */ PyObject *func_globals; /* A dictionary (命名空间) */ PyObject *func_defaults; /* NULL or a tuple，默认参数*/ PyObject *func_kwdefaults; /* NULL or a dict，默认参数 */ PyObject *func_closure; /* NULL or a tuple，用于闭包*/ PyObject *func_doc; /* The __doc__ attribute, can be anything */ PyObject *func_name; /* The __name__ attribute, a string object */ PyObject *func_dict; /* The __dict__ attribute, a dict or NULL */ PyObject *func_weakreflist; /* List of weak references */ PyObject *func_module; /* The __module__ attribute, can be anything */ PyObject *func_annotations; /* Annotations, a dict or NULL */ PyObject *func_qualname; /* The qualified name */&#125; PyFunctionObject; 如上，PyFunctionObject 中存放着对应的 CodeObject，除此之外还包含着运行需要的其他信息。这些其他信息，例如命名空间，只有在运行过程中才能获取到。可见 FuncObject 必然是在运行过程中创建的，而 CodeObject 却是在编译时创建的。 函数创建123456789101112def f(): passco_names: ('f',)co_consts: (&lt;code object f , file "demo.py", line 1&gt;, 'f', None) 1 0 LOAD_CONST 0 (&lt;code object f , file "demo.py", line 1&gt;) 2 LOAD_CONST 1 ('f') 4 MAKE_FUNCTION 0 /* 稍稍留意，此处为0 */ 6 STORE_NAME 0 (f) 8 LOAD_CONST 2 (None) 10 RETURN_VALUE 在前面我们已经知道，CodeObject 是一种嵌套结构，正如上面的 。命名空间 builtin 中的 ‘function’ 对应着 PyFunction_Type。既然已经知道 FuncObject 是动态创建的，那么MAKE_FUNCTION就很值得怀疑。 MAKE_FUNCTION 无参数12345678910TARGET(MAKE_FUNCTION) &#123; PyObject *qualname = POP(); PyObject *codeobj = POP(); PyFunctionObject *func = (PyFunctionObject *) PyFunction_NewWithQualName(codeobj, f-&gt;f_globals, qualname); ... // 根据 oparg, 处理默认值：func_defaults，func_closure等 PUSH((PyObject *)func); DISPATCH();&#125; 果然，从栈中取出名字+CodeObject，然后创建一个新的 FuncObject，封装属性，压入栈中。 PyFunction_NewWithQualName1234567891011121314// funcobject.c.9PyObject *PyFunction_NewWithQualName(PyObject *code, PyObject *globals, PyObject *qualname)&#123; PyFunctionObject *op; PyObject *doc, *consts, *module; op = PyObject_GC_New(PyFunctionObject, &amp;PyFunction_Type); ... // 封装属性 op-&gt;func_code = code; op-&gt;func_globals = globals; _PyObject_GC_TRACK(op); return (PyObject *)op;&#125; 如上，新的 FuncObject 属性封装分别在两个地方进行。完事后下一条指令STORE_NAME将栈顶的FuncObject 移入命名空间 local 中。 函数执行CALL_FUNCTION1234567891011// print('1')co_consts: ('1', None)co_names: ('print',) 1 0 LOAD_NAME 0 (print) 2 LOAD_CONST 0 ('1') 4 CALL_FUNCTION 1 6 POP_TOP 8 LOAD_CONST 1 (None) 10 RETURN_VALUE 执行函数时，从 local 中加载对象，执行指令CALL_FUNCTION。 123456789101112TARGET(CALL_FUNCTION) &#123; PyObject **sp, *res; PCALL(PCALL_ALL); sp = stack_pointer; // 获取到当前 f-&gt;f_stacktop res = call_function(&amp;sp, oparg, NULL); // 调用函数，同时传入函数参数个数 stack_pointer = sp; // 设置 栈顶 PUSH(res); if (res == NULL) &#123; goto error; &#125; DISPATCH();&#125; 在执行CALL_FUNCTION指令时，获得当前运行时栈栈顶指针后，进入call_function。 call_function1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// ceval.c.4806static PyObject *call_function(PyObject ***pp_stack, Py_ssize_t oparg, PyObject *kwnames)&#123; // 根据栈顶和函数参数个数，计算获取函数 PyObject **pfunc = (*pp_stack) - oparg - 1; PyObject *func = *pfunc; PyObject *x, *w; Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames); Py_ssize_t nargs = oparg - nkwargs; PyObject **stack; if (PyCFunction_Check(func)) &#123; // Py_TYPE(func) == &amp;PyCFunction_Type PyThreadState *tstate = PyThreadState_GET(); PCALL(PCALL_CFUNCTION); // pcall[6]++ stack = (*pp_stack) - nargs - nkwargs; C_TRACE(x, _PyCFunction_FastCallKeywords(func, stack, nargs, kwnames)); &#125; else &#123; // (func)-&gt;ob_type == &amp;PyMethod_Type if (PyMethod_Check(func) &amp;&amp; PyMethod_GET_SELF(func) != NULL) &#123; // ((PyMethodObject *)func) -&gt; im_self PyObject *self = PyMethod_GET_SELF(func); PCALL(PCALL_METHOD); PCALL(PCALL_BOUND_METHOD); Py_INCREF(self); // ((PyMethodObject *)func) -&gt; im_func func = PyMethod_GET_FUNCTION(func); Py_INCREF(func); Py_SETREF(*pfunc, self); nargs++; &#125; else &#123; Py_INCREF(func); &#125; stack = (*pp_stack) - nargs - nkwargs; if (PyFunction_Check(func)) &#123; x = fast_function(func, stack, nargs, kwnames); &#125; else &#123; x = _PyObject_FastCallKeywords(func, stack, nargs, kwnames); &#125; Py_DECREF(func); &#125; ... return x;&#125; 如上，代码不长，先是Check_type()，若对应PyMethod_Type，还得调用PyMethod_GET_FUNCTION，获取到最终的 func，并且把self 作为位置参数传递进去。最后，判断Func_Type，进行分发。 在前面PyObject_GC_New(PyFunctionObject, &amp;PyFunction_Type)中，传入的是PyFunction_Type，将进入到fast_function()。 fast_function1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// ceval.c.4916static PyObject *fast_function(PyObject *func, PyObject **stack, Py_ssize_t nargs, PyObject *kwnames)&#123; PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func); PyObject *globals = PyFunction_GET_GLOBALS(func); // func -&gt; func_globals PyObject *argdefs = PyFunction_GET_DEFAULTS(func); // func -&gt; func_defaults PyObject *kwdefs, *closure, *name, *qualname; PyObject **d; Py_ssize_t nkwargs = (kwnames == NULL) ? 0 : PyTuple_GET_SIZE(kwnames); Py_ssize_t nd; assert(PyFunction_Check(func)); assert(nargs &gt;= 0); assert(kwnames == NULL || PyTuple_CheckExact(kwnames)); assert((nargs == 0 &amp;&amp; nkwargs == 0) || stack != NULL); PCALL(PCALL_FUNCTION); PCALL(PCALL_FAST_FUNCTION); /* 处理无需 关键字参数的函数 */ if (co-&gt;co_kwonlyargcount == 0 &amp;&amp; nkwargs == 0 &amp;&amp; co-&gt;co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) &#123; /* 无默认参数，且参数个数刚好满足 func 需要 */ if (argdefs == NULL &amp;&amp; co-&gt;co_argcount == nargs) &#123; return _PyFunction_FastCall(co, stack, nargs, globals); &#125; /* 无参数传递，但 func 每个参数都有默认参数 */ else if (nargs == 0 &amp;&amp; argdefs != NULL &amp;&amp; co-&gt;co_argcount == Py_SIZE(argdefs)) &#123; stack = &amp;PyTuple_GET_ITEM(argdefs, 0); return _PyFunction_FastCall(co, stack, Py_SIZE(argdefs), globals); &#125; &#125; /* 含有关键字参数 */ kwdefs = PyFunction_GET_KW_DEFAULTS(func); // func -&gt; func_kwdefaults closure = PyFunction_GET_CLOSURE(func); // func -&gt; func_closure name = ((PyFunctionObject *)func) -&gt; func_name; qualname = ((PyFunctionObject *)func) -&gt; func_qualname; if (argdefs != NULL) &#123; /* 有参数传递时，需判断个数，以便获取默认参数 */ d = &amp;PyTuple_GET_ITEM(argdefs, 0); nd = Py_SIZE(argdefs); &#125; else &#123; d = NULL; nd = 0; &#125; return _PyEval_EvalCodeWithName((PyObject*)co, globals, (PyObject *)NULL, stack, nargs, nkwargs ? &amp;PyTuple_GET_ITEM(kwnames, 0) : NULL, stack + nargs, nkwargs, 1, d, (int)nd, kwdefs, closure, name, qualname);&#125;typedef struct &#123; PyObject_HEAD int co_argcount; /* 位置参数 *args 个数 */ int co_kwonlyargcount; /* #keyword only arguments */ int co_nlocals; /* 局部变量个数，包含位置参数 */ PyObject *co_code; /* 字节码序列，PyStringObject 形式 */ PyObject *co_consts; /* list (所有常量) */ PyObject *co_names; /* list of strings (所有符号) */ PyObject *co_varnames; /* tuple of strings (局部变量名) */ PyObject *co_freevars; /* tuple of strings (闭包所需变量名) */ PyObject *co_cellvars; /* tuple of strings ...&#125; PyCodeObject; 如上，CodeObject中含有 block 所需的关键字参数，当不含关键字参数时，调用_PyFunction_FastCall，否则获取到各种参数 ，执行_PyEval_EvalCodeWithName。 PyFunction_FastCall123456789101112131415161718192021222324252627// ceval.c.4879static PyObject*_PyFunction_FastCall(PyCodeObject *co, PyObject **args, Py_ssize_t nargs, PyObject *globals)&#123; PyFrameObject *f; PyThreadState *tstate = PyThreadState_GET(); PyObject **fastlocals; Py_ssize_t i; PyObject *result; PCALL(PCALL_FASTER_FUNCTION); f = PyFrame_New(tstate, co, globals, NULL); fastlocals = f-&gt;f_localsplus; for (i = 0; i &lt; nargs; i++) &#123; Py_INCREF(*args); fastlocals[i] = *args++; &#125; result = PyEval_EvalFrameEx(f,0); ++tstate-&gt;recursion_depth; Py_DECREF(f); --tstate-&gt;recursion_depth; return result;&#125; 如上，创建一个FrameObject，执行CodeObject中的字节码。函数执行完成后，将结果返回到 result中，完成了类似C语言的函数调用过程。关于 PyEval_EvalFrameEx 的执行逻辑，在 PyCodeObject/PyFrameObject 中已经叙述过。 这里很明显能够观察到，在新的栈帧对象中，执行的是传入的CodeObject中的字节码序列，上下文环境是通过命名空间globals实现。那么函数要调用其他的函数，该怎么实现？很容易想到在fast_function中的含有关键字参数的执行逻辑。 PyEval_EvalCodeWithName123456789101112131415161718192021222324252627// ceval.c.3888_PyEval_EvalCodeWithName(PyObject *_co, PyObject *globals, PyObject *locals, PyObject **args, Py_ssize_t argcount, PyObject **kwnames, PyObject **kwargs, Py_ssize_t kwcount, int kwstep, PyObject **defs, Py_ssize_t defcount, PyObject *kwdefs, PyObject *closure, PyObject *name, PyObject *qualname)&#123; ... /* Create the frame */ f = PyFrame_New(tstate, co, globals, locals); /* Create a dictionary for keyword parameters (**kwags) */ /* Copy positional arguments into local variables */ /* Pack other positional arguments into the *args argument */ /* Handle keyword arguments passed as two strided arrays */ /* Check the number of positional arguments */ /* Add missing positional arguments (copy default values from defs) */ /* Add missing keyword arguments (copy default values from kwdefs) */ /* Allocate and initialize storage for cell vars, and copy free vars into frame. */ /* Copy closure variables to free variables */ /* Handle generator/coroutine/asynchronous generator */ retval = PyEval_EvalFrameEx(f,0);&#125; 如上，不管有参数无参数，最终都是创建栈帧对象，在新的上下文环境执行被调函数字节码指令。唯一的区别仅在于，对被调函数可能存在的参数进行处理，其中涉及到可变参数，默认参数，闭包参数等。详细内容可以阅读源码。 这里要提一句，判断函数是否含有可变参数，是通过 CodeObject-&gt;co_flags 字段实现。12345#define CO_VARARGS 0x0004 /* CodeObject 存在可变位置参数 *args */#define CO_VARKEYWORDS 0x0008 /* CodeObject 存在可变关键字参数 **kwargs *//* Create a dictionary for keyword parameters (**kwags) */if (co-&gt;co_flags &amp; CO_VARKEYWORDS) &#123; ... &#125; 函数参数1234567891011121314151617181920def fun(a, b=3): passfun(1) 3 10 LOAD_NAME 0 (fun) 12 LOAD_CONST 3 (1) 14 CALL_FUNCTION 1fun(1, 2) 3 10 LOAD_NAME 0 (fun) 12 LOAD_CONST 3 (1) 14 LOAD_CONST 4 (2) 16 CALL_FUNCTION 2fun(1, b=2) 3 10 LOAD_NAME 0 (fun) 12 LOAD_CONST 3 (1) 14 LOAD_CONST 4 (2) 16 LOAD_CONST 5 ((&apos;b&apos;,)) 18 CALL_FUNCTION_KW 2 由上可见，函数的参数是位置参数还是关键字参数，是跟参数的传递方式有关，而与定义无关。函数的参数通过指令LOAD_*压入栈中，那么问题来了，上面的例子中b=3是如何生效的？ MAKE_FUNCTION 带参数1234567def fun(a, b=3): pass 1 0 LOAD_CONST 6 ((3,)) 2 LOAD_CONST 1 (&lt;code object fun, file &quot;demo.py&quot;, line 1&gt;) 4 LOAD_CONST 2 (&apos;fun&apos;) 6 MAKE_FUNCTION 1 /* 注意此处 */ 此处，指令序列MAKE_FUNCTION比我们在函数创建中用到的，多了一个参数 1。所以，是时候来看下在MAKE_FUNCTION中，我们注释的那一段内容了。 123456789101112131415161718192021TARGET(MAKE_FUNCTION) &#123; ... // 根据 oparg, 处理默认值：func_defaults，func_closure等 if (oparg &amp; 0x08) &#123; assert(PyTuple_CheckExact(TOP())); func -&gt;func_closure = POP(); &#125; if (oparg &amp; 0x04) &#123; assert(PyDict_CheckExact(TOP())); func-&gt;func_annotations = POP(); &#125; if (oparg &amp; 0x02) &#123; assert(PyDict_CheckExact(TOP())); func-&gt;func_kwdefaults = POP(); &#125; if (oparg &amp; 0x01) &#123; assert(PyTuple_CheckExact(TOP())); func-&gt;func_defaults = POP(); &#125; ...&#125; 真相很明显了，默认参数、函数注解、闭包属性，都各自从栈顶POP，放入 FuncObj 属性中。下面就来看一个实际的例子。 MAKE_FUNCTION 131234567891011121314151617181920// demo.pydef f(): clu = &apos;clu&apos; def c(a:int = 1): print(clu)co = compile(open(&apos;demo.py&apos;).read(),&apos;demo.py&apos;,&apos;exec&apos;); import dis; f = co.co_consts[0]; dis.dis(f) 2 0 LOAD_CONST 1 (&apos;clu&apos;) 2 STORE_DEREF 0 (clu) 3 4 LOAD_CONST 6 ((1,)) 6 LOAD_GLOBAL 0 (int) 8 LOAD_CONST 3 ((&apos;a&apos;,)) 10 BUILD_CONST_KEY_MAP 1 12 LOAD_CLOSURE 0 (clu) 14 BUILD_TUPLE 1 16 LOAD_CONST 4 (&lt;code object c , file &quot;demo.py&quot;, line 3&gt;) 18 LOAD_CONST 5 (&apos;f.&lt;locals&gt;.c&apos;) 20 MAKE_FUNCTION 13 /* 注意此处，13 = 8+4+1*/ 22 STORE_FAST 0 (c) 如上，在def c中，同时用到了3种。那么问题来了剩下的func_kwdefaults如何实现？留给大家思考。哈~欢迎留言~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyFunctionObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】Python 异常控制]]></title>
    <url>%2F2018%2F07%2F21%2F1.8.Python%20%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[参考 《Python源码剖析》—— 陈儒 前言本章将通过字节码指令，探究 Python 中try-except等异常控制语句的实现及原理。阅读本章前需了解PyCodeObject/PyFrameObject。 开局一张陈儒先生著作《Python 源码剖析》中的附图： 1/0123456789101/0co_consts: (1, 0, None) 1 0 LOAD_CONST 0 (1) 2 LOAD_CONST 1 (0) 4 BINARY_TRUE_DIVIDE 6 POP_TOP 8 LOAD_CONST 2 (None) 10 RETURN_VALUE 其他的先不谈，先来看上面的字节码。4+6 就是一个/运算。很明显，重点落在BINARY_TRUE_DIVIDE中。 BINARY_TRUE_DIVIDE123456789101112131415161718#define BINARY_TRUE_DIVIDE 27TARGET(BINARY_TRUE_DIVIDE) &#123; PyObject *divisor = POP(); PyObject *dividend = TOP(); PyObject *quotient = PyNumber_TrueDivide(dividend, divisor); Py_DECREF(dividend); Py_DECREF(divisor); SET_TOP(quotient); if (quotient == NULL) goto error; DISPATCH();&#125;PyNumber_TrueDivide -&gt; binary_op(v, w, NB_SLOT(nb_true_divide), "/")-&gt; binary_op1(v, w, op_slot)-&gt; v-&gt;ob_type-&gt;tp_as_number[op_slot](v, w)-&gt; long_true_divide(v, w) 1/0最终进入到longobject.c中去执行，源码中有很长一段关于除法运算的注释，有兴趣可以看看。我们这里只关注异常处理的部分。 long_true_divide1234567891011// longobject.c.long_true_divideif (Py_ABS(Py_SIZE(b)) == 0) &#123; PyErr_SetString(PyExc_ZeroDivisionError, "division by zero"); goto error;&#125;overflow: PyErr_SetString(PyExc_OverflowError, "integer division result too large for a float");error: return NULL; 在前面的部分中，其实我们已经看见了 Python 关于故障报错的处理方式，ZeroDivisionError同样是通过这种方式实现。那么，问题来了，这个PyExc_ZeroDivisionError又是个什么东西？ PyErrorObject123456789101112131415161718192021222324// pyport.hdefine PyAPI_DATA(RTYPE) extern RTYPE// pyerrors.hPyAPI_DATA(PyObject *) PyExc_ZeroDivisionError;typedef struct &#123; PyException_HEAD&#125; PyBaseExceptionObject;typedef struct &#123; PyException_HEAD PyObject *msg; PyObject *filename; PyObject *lineno; PyObject *offset; PyObject *text; PyObject *print_file_and_line;&#125; PySyntaxErrorObject;PyAPI_FUNC(void) PyErr_SetString( PyObject *exception, const char *string /* decoded from utf-8 */); 果然，一切皆为对象。long_true_divide 似乎就干了两件事，SetString&amp;Return NULL。BINARY_TRUE_DIVIDE先把结果入栈SET_TOP()，判断结果为空，goto error。 goto error123456789101112131415error: why = WHY_EXCEPTION; // !!! /* Log traceback info. */ PyTraceBack_Here(f);fast_block_end: /* Unwind stacks if a (pseudo) exception occurred */ while (why != WHY_NOT &amp;&amp; f-&gt;f_iblock &gt; 0) &#123; ... &#125; /* unwind stack */ /* End the loop if we still have an error (or return) */ if (why != WHY_NOT) break;&#125; /* main loop */ emmm，代码很长。从上面的轮廓可以看见，在 error 中 TraceBack。在 fast_block_end 中，尝试在栈链上逐级捕捉错误。否则，最终退出循环，结束程序。 PyTraceBack_Here12345678910111213// traceback.c.133int PyTraceBack_Here(PyFrameObject *frame)&#123; PyObject *exc, *val, *tb, *newtb; /* 先保存，后清空 */ PyErr_Fetch(&amp;exc, &amp;val, &amp;tb); // 构建新的 traceback，形成链表 newtb = (PyObject *)newtracebackobject((PyTracebackObject *)tb,frame); // 将新的异常对象存储到线程状态对象中 PyErr_Restore(exc, val, newtb); Py_XDECREF(tb); return 0;&#125; 如上，代码很简单，将 Frame 的错误信息保存起来，构建一个新的 tb，插入到原有的链中。 PyErr_Fetch123456789101112131415// errors.c.339voidPyErr_Fetch(PyObject **p_type, PyObject **p_value, PyObject **p_traceback)&#123; // 保存线程异常对象，并清空 PyThreadState *tstate = PyThreadState_GET(); *p_type = tstate-&gt;curexc_type; *p_value = tstate-&gt;curexc_value; *p_traceback = tstate-&gt;curexc_traceback; tstate-&gt;curexc_type = NULL; tstate-&gt;curexc_value = NULL; tstate-&gt;curexc_traceback = NULL;&#125; newtracebackobject123456789101112131415161718// traceback.c.111static PyTracebackObject *newtracebackobject(PyTracebackObject *next, PyFrameObject *frame)&#123; PyTracebackObject *tb; ... tb = PyObject_GC_New(PyTracebackObject, &amp;PyTraceBack_Type); if (tb != NULL) &#123; Py_XINCREF(next); tb-&gt;tb_next = next; // 关键步骤，链表插入 Py_XINCREF(frame); tb-&gt;tb_frame = frame; tb-&gt;tb_lasti = frame-&gt;f_lasti; tb-&gt;tb_lineno = PyFrame_GetLineNumber(frame); PyObject_GC_Track(tb); &#125; return tb;&#125; try-except1234567891011121314151617181920212223242526272829303132333435363738394041424344try: 1 / 0except ZeroDivisionError: passco_consts: (1, 0, None)co_names: ('ZeroDivisionError',) 1 0 SETUP_EXCEPT 12 (to 14)/* 在FOR控制流中已经提到，等效于 SETUP_LOOP，构建一个 TryBlock PyFrame_BlockSetup( PyFrameObject * = f, int type = opcode = SETUP_EXCEPT, int handler = INSTR_OFFSET() + oparg = 14, int level = STACK_LEVEL() = stack_pointer - f-&gt;f_valuestack ) b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock++]; 对b 进行赋值;*/ 2 2 LOAD_CONST 0 (1) 4 LOAD_CONST 1 (0) 6 BINARY_TRUE_DIVIDE/* PyErr_SetString(PyExc_ZeroDivisionError); SET_TOP(NULL); goto error; PyTraceBack_Here(); goto fast_block_end;*/ 8 POP_TOP 10 POP_BLOCK 12 JUMP_FORWARD 20 (to 34) // JUMPBY(20) 3 &gt;&gt; 14 DUP_TOP 16 LOAD_NAME 0 (ZeroDivisionError) 18 COMPARE_OP 10 (exception match) 20 POP_JUMP_IF_FALSE 32 22 POP_TOP 24 POP_TOP 26 POP_TOP 4 28 POP_EXCEPT 30 JUMP_FORWARD 2 (to 34) &gt;&gt; 32 END_FINALLY &gt;&gt; 34 LOAD_CONST 2 (None) 36 RETURN_VALUE 前面关于goto error的问题，我们先放一放，先看一段字节码指令。一段try-except的代码，编译结果高达30+行，即使是try 1/1结果也是30+行。 前面我们已经知道1/0 对应 6+8。如果顺序执行，字节码12，就直接跳转到字节码34，结束程序，这显然是不可能的。那么必然，在BINARY_TRUE_DIVIDE中会发生些什么。想起来没有？对，goto erorr！接下来就到了fast_block_end。 fast_block_end123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990why = WHY_EXCEPTION;while (why != WHY_NOT &amp;&amp; f-&gt;f_iblock &gt; 0) &#123; /* Peek at the current block */ PyTryBlock *b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock - 1]; /* Now we have to pop the block. */ f-&gt;f_iblock--; if (b-&gt;b_type == EXCEPT_HANDLER) &#123; // == 257 UNWIND_EXCEPT_HANDLER(b); continue; &#125; UNWIND_BLOCK(b); if (b-&gt;b_type == SETUP_LOOP &amp;&amp; why == WHY_BREAK) &#123; why = WHY_NOT; JUMPTO(b-&gt;b_handler); break; &#125; if (why == WHY_EXCEPTION &amp;&amp; (b-&gt;b_type == SETUP_EXCEPT || b-&gt;b_type == SETUP_FINALLY)) &#123; // 判断是否在 try-except 块中 PyObject *exc, *val, *tb; int handler = b-&gt;b_handler; /* 在FOR控制流 SETUP_LOOP 中有提到 从数组中获取一个新的 TryBlock，并放入信息 PyFrame_BlockSetup( PyFrameObject * = f, int type = EXCEPT_HANDLER, int handler = -1, int level = STACK_LEVEL() = stack_pointer - f-&gt;f_valuestack ) 构建一个新的 block 用于处理异常 */ PyFrame_BlockSetup(f, EXCEPT_HANDLER, -1, STACK_LEVEL()); /* 在 PyTraceBack_Here 中，已经构建了一个新的 tb 此处，将异常信息压栈 */ PUSH(tstate-&gt;exc_traceback); PUSH(tstate-&gt;exc_value); if (tstate-&gt;exc_type != NULL) &#123; PUSH(tstate-&gt;exc_type); &#125; else &#123; Py_INCREF(Py_None); PUSH(Py_None); &#125; /* 先保存，后清空 线程异常对象 */ PyErr_Fetch(&amp;exc, &amp;val, &amp;tb); /* 详见 errors.c。 递归调用 PyErr_NormalizeExceptionEx() */ PyErr_NormalizeException(&amp;exc, &amp;val, &amp;tb); if (tb != NULL) PyException_SetTraceback(val, tb); else PyException_SetTraceback(val, Py_None); Py_INCREF(exc); tstate-&gt;exc_type = exc; Py_INCREF(val); tstate-&gt;exc_value = val; tstate-&gt;exc_traceback = tb; if (tb == NULL) tb = Py_None; Py_INCREF(tb); /* 压入运行时栈 */ PUSH(tb); PUSH(val); PUSH(exc); /* 结束异常发现阶段，跳转到 handler，进行异常处理 */ why = WHY_NOT; JUMPTO(handler); break; &#125; if (b-&gt;b_type == SETUP_FINALLY) &#123; if (why &amp; (WHY_RETURN | WHY_CONTINUE)) PUSH(retval); PUSH(PyLong_FromLong((long)why)); why = WHY_NOT; JUMPTO(b-&gt;b_handler); break; &#125;&#125; /* unwind stack */ 程序抛出故障，将沿着 tb 链，逐级寻找一个 try-except最终找到一个except，将跳转到 handler，否则直接退出程序，显示栈中压入的错误信息。而这个hander，是跟字节码SETUP_EXCEPT/SETUP_FINALLY`对应的。 12345678910111213141 0 SETUP_EXCEPT 12 (to 14)...3 &gt;&gt; 14 DUP_TOP 16 LOAD_NAME 0 (ZeroDivisionError) 18 COMPARE_OP 10 (exception match) 20 POP_JUMP_IF_FALSE 32 22 POP_TOP 24 POP_TOP 26 POP_TOP4 28 POP_EXCEPT 30 JUMP_FORWARD 2 (to 34) &gt;&gt; 32 END_FINALLY &gt;&gt; 34 LOAD_CONST 2 (None) 36 RETURN_VALUE 在随后的字节码指令中，进行异常比较。若异常匹配，将POP三连，扔掉栈中的异常信息 跳转到正常代码。当异常不匹配时，直接跳转到END_FINALLY。 END_FINALLY12345678910111213141516171819PREDICTED(END_FINALLY);TARGET(END_FINALLY) &#123; PyObject *status = POP(); if (PyLong_Check(status)) &#123; ... // 处理 with 上下文 &#125; else if (PyExceptionClass_Check(status)) &#123; PyObject *exc = POP(); PyObject *tb = POP(); PyErr_Restore(status, exc, tb); why = WHY_EXCEPTION; goto fast_block_end; &#125; else if (status != Py_None) &#123; ... &#125; Py_DECREF(status); DISPATCH();&#125; 异常不匹配，意味着异常并未被成功捕捉，需要再次进行抛出。END_FINALLY就是干这个的。如上，在判断语句中，能够清除的发现，将异常对象从栈中取出，重新放回线程状态对象中。再次设置 why 的状态，Python 虚拟机重新进入异常发生状态。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>try-except</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】Python 控制字节码执行]]></title>
    <url>%2F2018%2F07%2F21%2F1.7.Python%20%E6%8E%A7%E5%88%B6%E5%AD%97%E8%8A%82%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言本章将通过几个字节码指令，探究 Python 中if及for语句的实现及原理，阅读本章前需了解PyCodeObject/PyFrameObject。 IF控制流（JUMP_*）123456789101112a = 0if a &gt; 0: b = 3elif a &lt; 0: b = -3else: b = 0c = 1co_consts: (0, 3, 1, None, -3)co_names: (&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 1234567891011121314151617181920212223242526 1 0 LOAD_CONST 0 (0) 2 STORE_NAME 0 (a) 3 4 LOAD_NAME 0 (a) 6 LOAD_CONST 0 (0) 8 COMPARE_OP 4 (&gt;) // 执行比较操作 10 POP_JUMP_IF_FALSE 18 // if POP()== Py_False: JUMPTO(18) 4 12 LOAD_CONST 1 (3) 14 STORE_NAME 1 (b) 16 JUMP_FORWARD 18 (to 36) // JUMPBY(18) 5 &gt;&gt; 18 LOAD_NAME 0 (a) 20 LOAD_CONST 0 (0) 22 COMPARE_OP 0 (&lt;) 24 POP_JUMP_IF_FALSE 32// if POP()== Py_False: JUMPTO(32) 6 26 LOAD_CONST 4 (-3) 28 STORE_NAME 1 (b) 30 JUMP_FORWARD 4 (to 36) 8 &gt;&gt; 32 LOAD_CONST 0 (0) 34 STORE_NAME 1 (b) 9 &gt;&gt; 36 LOAD_CONST 2 (1) 38 STORE_NAME 2 (c) 40 LOAD_CONST 3 (None) 42 RETURN_VALUEtypedef uint16_t _Py_CODEUNIT; // 2字节#define JUMPTO(x) (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))#define JUMPBY(x) (next_instr += (x) / sizeof(_Py_CODEUNIT)) 可以看出，比较操作，会调用 COMPARE_OP，然后根据结果进行跳转。而大于符号&gt;，在数组 opcode.h/enum cmp_op{}中，索引为4。 我们知道 first_instr，始终指向字节码开始位置。因此，JUMPTO(18)，最终的结果是，改变下一条 code 指针next_instr的值，实际上就是跳转到索引为 18 的字节码处。JUMPBY(18)相当于在下一条的基础上，跳转偏移量为18。 这里要说一下还是说一下，为什么要(x) / sizeof(_Py_CODEUNIT)。在前面我们也已经提到，STORE_NAME本身是一个数字，而这个数字是_Py_CODEUNIT形式。所以，每增加一条指令，指针就要移动相应的位置。 还需要说明的是，这里的JUMP*皆是 Python 用户层面的跳转，影响的是用户代码逻辑。而goto fast_block_end，是在 Python虚拟机层面的跳转，影响的是虚拟机的状态。 COMPARE_OP12345678910111213141516171819202122232425262728293031323334353637// opcode.henum cmp_op &#123;PyCmp_LT=Py_LT, PyCmp_LE=Py_LE, PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE, PyCmp_GT=Py_GT, PyCmp_GE=Py_GE, PyCmp_IN, PyCmp_NOT_IN, PyCmp_IS, PyCmp_IS_NOT, PyCmp_EXC_MATCH, PyCmp_BAD&#125;;TARGET(COMPARE_OP) &#123; PyObject *right = POP(); PyObject *left = TOP(); PyObject *res = cmp_outcome(oparg, left, right); Py_DECREF(left); Py_DECREF(right); SET_TOP(res); if (res == NULL) goto error; PREDICT(POP_JUMP_IF_FALSE); PREDICT(POP_JUMP_IF_TRUE); DISPATCH();&#125;static PyObject *cmp_outcome(int op, PyObject *v, PyObject *w)&#123; int res = 0; switch (op) &#123; case PyCmp_IS: res = (v == w); // 注意，此处是 PyObject 之间的比较 break; case PyCmp_IS_NOT: res = (v != w); // 而不是 C对象 break; case PyCmp_IN: ... &#125; v = res ? Py_True : Py_False; Py_INCREF(v); return v;&#125; 从定义中可以看见，in/is 操作也是走 COMPARE_OP 流程。并且返回的是 PyObject。 FOR控制流12345678910111213141516171819202122232425262728293031323334353637# demo.pya = [1, 2, 3, 4]for i in a: print(i)co_consts: (1, 2, 3, 4, None)co_names: (&apos;a&apos;, &apos;i&apos;, &apos;print&apos;) 1 0 LOAD_CONST 0 (1) 2 LOAD_CONST 1 (2) 4 LOAD_CONST 2 (3) 6 LOAD_CONST 3 (4) 8 BUILD_LIST 4 10 STORE_NAME 0 (a) 2 12 SETUP_LOOP 20 (to 34) 14 LOAD_NAME 0 (a) 16 GET_ITER &gt;&gt; 18 FOR_ITER 12 (to 32) 20 STORE_NAME 1 (i) 3 22 LOAD_NAME 2 (print) 24 LOAD_NAME 1 (i) 26 CALL_FUNCTION 1 28 POP_TOP 30 JUMP_ABSOLUTE 18 &gt;&gt; 32 POP_BLOCK &gt;&gt; 34 LOAD_CONST 4 (None) 36 RETURN_VALUETARGET(SETUP_LOOP) // 三种方式，都走该函数TARGET(SETUP_EXCEPT) // loop/except/finallyTARGET(SETUP_FINALLY) &#123; PyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg, STACK_LEVEL()); DISPATCH();&#125; 下面是很重要的循环控制，关于 FrameObject 的操作，自然在frameobject.c。 SETUP_LOOP（PyFrame_BlockSetup）123456789101112131415161718192021222324252627#define CO_MAXBLOCKS 20 /* Max static block nesting within a function */typedef struct &#123; int b_type; /* what kind of block this is */ int b_handler; /* where to jump to find handler */ int b_level; /* value stack level to pop to */&#125; PyTryBlock;voidPyFrame_BlockSetup(PyFrameObject *f, int type, int handler, int level)&#123; PyTryBlock *b; // index in f_blockstack，在 PyFrame_New 中，初始化为 0 if (f-&gt;f_iblock &gt;= CO_MAXBLOCKS) Py_FatalError("XXX block stack overflow"); /* 在 PyFrameObject 结构体中，被定义为 PyTryBlock f_blockstack[CO_MAXBLOCKS] 获取 PyTryBlock，指针 ++ */ b = &amp;f-&gt;f_blockstack[f-&gt;f_iblock++]; /* 定义 code block 块类型 ，直接跟 opcode 一致。 SETUP_* -&gt; loop/except/finally */ b-&gt;b_type = type; // block 类型 b-&gt;b_level = level; // 保存栈位置 b-&gt;b_handler = handler;&#125; 这里的 f 自然是，系统运行时的当前 FrameObject。在数组中获取一个新的 block，并存放相关信息。 GET_ITER123456789101112131415 16 GET_ITER &gt;&gt; 18 FOR_ITER 12 (to 32)TARGET(GET_ITER) &#123; /* before: [obj]; after [getiter(obj)] */ PyObject *iterable = TOP(); // 出栈 PyObject *iter = PyObject_GetIter(iterable); Py_DECREF(iterable); SET_TOP(iter); // 入栈 if (iter == NULL) goto error; PREDICT(FOR_ITER); PREDICT(CALL_FUNCTION); DISPATCH();&#125; 如上，先从栈顶获取到对象，处理后再推入栈中。 123456789101112131415161718192021222324252627// object.htypedef PyObject *(*getiterfunc) (PyObject *);// abstract.c.3127PyObject * PyObject_GetIter(PyObject *o)&#123; PyTypeObject *t = o-&gt;ob_type; getiterfunc f = NULL; f = t-&gt;tp_iter; // == list_iter if (f == NULL) &#123; if (PySequence_Check(o)) return PySeqIter_New(o); return type_error("'%.200s' object is not iterable", o); &#125; else &#123; PyObject *res = (*f)(o); if (res != NULL &amp;&amp; !PyIter_Check(res)) &#123; PyErr_Format(PyExc_TypeError, "iter() returned non-iterator " "of type '%.100s'", res-&gt;ob_type-&gt;tp_name); Py_DECREF(res); res = NULL; &#125; return res; &#125;&#125; 这里传入的 Object *o，是上一步获取到的 PyListObject，通过获取 ob_type，调用其类型对象定义的tp_iter方法，即 list_iter。 1234567891011121314151617181920212223static PyObject * list_iter(PyObject *seq)&#123; listiterobject *it; if (!PyList_Check(seq)) &#123; PyErr_BadInternalCall(); return NULL; &#125; it = PyObject_GC_New(listiterobject, &amp;PyListIter_Type); if (it == NULL) return NULL; it-&gt;it_index = 0; Py_INCREF(seq); it-&gt;it_seq = (PyListObject *)seq; // 赋值 _PyObject_GC_TRACK(it); return (PyObject *)it;&#125;typedef struct &#123; PyObject_HEAD Py_ssize_t it_index; PyListObject *it_seq; /* Set to NULL when iterator is exhausted */&#125; listiterobject; 如上，调用 iter 方法，返回的是一个新的对象，即我们常说的迭代器。 FOR_ITER12345678910111213141516 &gt;&gt; 18 FOR_ITER 12 (to 32) 30 JUMP_ABSOLUTE 18PREDICTED(FOR_ITER);TARGET(FOR_ITER) &#123; /* before: [iter]; after: [iter, iter()] *or* [] */ PyObject *iter = TOP(); PyObject *next = (*iter-&gt;ob_type-&gt;tp_iternext)(iter); if (next != NULL) &#123; PUSH(next); PREDICT(STORE_FAST); PREDICT(UNPACK_SEQUENCE); DISPATCH(); &#125; ...&#125; 通过 GET_ITER，将一个栈顶的对象转换成迭代器。如上，调用 PyTypeObject 的tp_iternext方法，获取 next 值，入栈。最终处理 next==NULL 情况。当 for 循环字据执行完成后，执行绝对跳转，从头开始继续执行。 JUMP_ABSOLUTE12345678910 &gt;&gt; 18 FOR_ITER 12 (to 32) 30 JUMP_ABSOLUTE 18#define JUMPTO(x) (next_instr = first_instr + (x) / sizeof(_Py_CODEUNIT))PREDICTED(JUMP_ABSOLUTE);TARGET(JUMP_ABSOLUTE) &#123; JUMPTO(oparg); DISPATCH();&#125; JUMP_ABSOLUTE 18 表示跳转到，距离字节码指令序列的开始向前18个字节处。 POP_BLOCK（结束循环）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 &gt;&gt; 18 FOR_ITER 12 (to 32) &gt;&gt; 32 POP_BLOCKTARGET(FOR_ITER) &#123; /* before: [iter]; after: [iter, iter()] *or* [] */ PyObject *iter = TOP(); PyObject *next = (*iter-&gt;ob_type-&gt;tp_iternext)(iter); if (next != NULL) &#123; ... &#125; if (PyErr_Occurred()) &#123; if (!PyErr_ExceptionMatches(PyExc_StopIteration)) goto error; else if (tstate-&gt;c_tracefunc != NULL) call_exc_trace(tstate-&gt;c_tracefunc, tstate-&gt;c_traceobj, tstate, f); PyErr_Clear(); &#125; /* iterator ended normally */ STACKADJ(-1); // stack_pointer += n Py_DECREF(iter); JUMPBY(oparg); // (next_instr += (x) / sizeof(_Py_CODEUNIT)) PREDICT(POP_BLOCK); DISPATCH();&#125;PREDICTED(POP_BLOCK);TARGET(POP_BLOCK) &#123; PyTryBlock *b = PyFrame_BlockPop(f); UNWIND_BLOCK(b); DISPATCH();&#125;// frameobject.c.788PyTryBlock * PyFrame_BlockPop(PyFrameObject *f)&#123; PyTryBlock *b; if (f-&gt;f_iblock &lt;= 0) Py_FatalError("XXX block stack underflow"); // 指针 --，返回的是 SETUP_LOOP（PyFrame_BlockSetup) 中获取 TryBlock b = &amp;f-&gt;f_blockstack[--f-&gt;f_iblock]; return b;&#125;#define UNWIND_BLOCK(b) \ while (STACK_LEVEL() &gt; (b)-&gt;b_level) &#123; \ PyObject *v = POP(); \ Py_XDECREF(v); \ &#125; FOR_ITER在调用时，附带有参数 12，下一条为20，JUMPBY 跳转到32，执行POP_BLOCK。最终，恢复 f_iblock，到循环之前，恢复运行时栈到循环之前。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyCodeObject</tag>
        <tag>EvalFrame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】Python 一般字节码执行]]></title>
    <url>%2F2018%2F07%2F21%2F1.6.Python%20%E4%B8%80%E8%88%AC%E5%AD%97%E8%8A%82%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言本章将通过几个常用的字节码指令，来了解 Python 字节码指令执行的逻辑。阅读本章前需了解PyCodeObject/PyFrameObject。 前情提要123456789101112_PyEval_EvalFrameDefault(PyFrameObject *f, int throwflag)&#123; // ceval.c.1144 for (;;) &#123; // ceval.c.1267 switch (opcode) &#123; TARGET(LOAD_FAST) &#123; ... &#125; TARGET(LOAD_CONST) &#123; ... &#125; ... &#125; &#125;&#125; 在前面我们提到，解释器会在 _PyEval_EvalFrameDefault进入for(;;)死循环，不断加载字节码指令，并执行。123456789101112# demo.pya = 1&gt;&gt;&gt;co = compile(open('demo.py').read(),'demo.py','exec'); import dis; dis.dis(co) 1 0 LOAD_CONST 0 (1) 2 STORE_NAME 0 (a) 2 4 BUILD_MAP 0 6 STORE_NAME 1 (b) 8 LOAD_CONST 1 (None) 10 RETURN_VALUE 字节码序列： 第一列：字节码对应源码中的行号 第二列：当前字节码指令在 co_code 中的偏移位置 第三列：当前字节码指令 第四列：oparg，指令参数 最后一列：当前字节码指令的参数实际内容 LOAD_CONST12345678// 1 0 LOAD_CONST 0 (1)TARGET(LOAD_CONST) &#123; PyObject *value = GETITEM(consts, oparg); // 加载序号为 oparg 的元素 Py_INCREF(value); // 增加引用 PUSH(value); // 入栈 FAST_DISPATCH(); // 继续循环&#125; consts = f-&gt;f_code-&gt;co_consts，即 CodeObject 中的所有常量，一张常量表。LOAD_CONST 完成后，栈顶增加元素 1，栈顶指针下移。 STORE_NAME1234567891011121314151617181920212223// 2 STORE_NAME 0 (a)TARGET(STORE_NAME) &#123; PyObject *name = GETITEM(names, oparg); // 再次加载元素（a） PyObject *v = POP(); // 从运行时栈中获取值 PyObject *ns = f-&gt;f_locals; int err; if (ns == NULL) &#123; PyErr_Format(PyExc_SystemError, "no locals found when storing %R", name); Py_DECREF(v); goto error; &#125; // 将 符号name-值v 的映射关系存储到 locals 中 if (PyDict_CheckExact(ns)) err = PyDict_SetItem(ns, name, v); else err = PyObject_SetItem(ns, name, v); Py_DECREF(v); if (err != 0) goto error; DISPATCH();&#125; 注意到，上一步刚进行了压栈操作，第二步就进行了出栈。然后再次获取第0个元素，并且组成k-v对的形式，映射到 locals 字典中。此时，栈空，f_locals 指针依然指向开始位置。 BUILD_MAP/BUILD_LIST123456789101112131415161718192021222324252627282930313233343536373839404142434445#define PEEK(n) (stack_pointer[-(n)])TARGET(BUILD_MAP) &#123; Py_ssize_t i; PyObject *map = _PyDict_NewPresized((Py_ssize_t)oparg); if (map == NULL) goto error; for (i = oparg; i &gt; 0; i--) &#123; int err; PyObject *key = PEEK(2*i); // 偶数 PyObject *value = PEEK(2*i - 1); // 奇数 err = PyDict_SetItem(map, key, value); if (err != 0) &#123; Py_DECREF(map); goto error; &#125; &#125; while (oparg--) &#123; // 这里挺有趣，每次都 POP 两个 Py_DECREF(POP()); Py_DECREF(POP()); /* 从上面的偶数，奇数，也不难猜出。 字典 k-v 都是通过 LOAD_CONST，压入了栈中 比较奇特的是：d = &#123;"X": "Z", 'a': 'b'&#125;，结果是 key 在一起 &gt;&gt;&gt; co.co_consts == ('Z', 'b', ('X', 'a'), None) 字节码对应 BUILD_CONST_KEY_MAP */ &#125; PUSH(map); DISPATCH();&#125;TARGET(BUILD_LIST) &#123; PyObject *list = PyList_New(oparg); if (list == NULL) goto error; while (--oparg &gt;= 0) &#123; // 同样，列表中的值，也是在栈中，依此读取 PyObject *item = POP(); PyList_SET_ITEM(list, oparg, item); &#125; PUSH(list); DISPATCH();&#125; RETURN_VALUE12345678 8 LOAD_CONST 1 (None) 10 RETURN_VALUETARGET(RETURN_VALUE) &#123; retval = POP(); why = WHY_RETURN; // 0x0008, /* 'return' statement */ goto fast_block_end;&#125; 最后，临走前将返回值 None 压入栈中，然后在 POP 出来，break 掉死循环。 BINARY_ADD1234a = 1 + 3co_consts: (1, 3, None, 4)co_names: (&apos;a&apos;,) 这种，在编译时直接就计算了结果。 1234567891011121314a = 1b = 2c = 3d = a + b * (c + c) 4 12 LOAD_NAME 0 (a) 14 LOAD_NAME 1 (b) 16 LOAD_NAME 2 (c) 18 LOAD_NAME 2 (c) 20 BINARY_ADD 22 BINARY_MULTIPLY 24 BINARY_ADD 26 STORE_NAME 3 (d) 这种，就是正常的，先调用LOAD_NAME在调用BINARY_ADD。而且，比较重要的是，只能每次两个两个相加，并且自左向右结合，优先级在编译时考虑。 LOAD_NAME1234567891011121314151617181920212223// names = co-&gt;co_names，可见是从 符号表中加载TARGET(LOAD_NAME) &#123; PyObject *name = GETITEM(names, oparg); PyObject *locals = f-&gt;f_locals; PyObject *v; v = PyObject_GetItem(locals, name); if (v == NULL) &#123; v = PyDict_GetItem(f-&gt;f_globals, name); Py_XINCREF(v); if (v == NULL) &#123; v = PyDict_GetItem(f-&gt;f_builtins, name); if (v == NULL) &#123; goto error; &#125; Py_INCREF(v); &#125; &#125; PUSH(v); DISPATCH();&#125; 精简代码如上，很好理解，从 locals -&gt; globals -&gt; builtins，找到了，就压栈，找不到就报错。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyCodeObject</tag>
        <tag>EvalFrame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】PyCodeObject/PyFrameObject]]></title>
    <url>%2F2018%2F07%2F21%2F1.5.Python%20Code%20Frame%2F</url>
    <content type="text"><![CDATA[参考 《Python源码剖析》—— 陈儒 PEP3147 前言事实上，Python虽然是解释型语言，但也需要经过 源文件 -&gt; 编译 -&gt; 可执行文件 -&gt; 执行整个过程。12345javac Example.java -&gt; Example.classjava Example.class -&gt; 输出python Example.py -&gt; 创建或加载 PyCodeObject -&gt; 输出保存PyCodeObject到 -&gt; Example.pyc 如上，编译器在编译产生 code 后由虚拟机执行。Python 与 Java 不同之处在于 Python 的虚拟机是一种抽象层次更高的虚拟机。 在 编译结束后，Python 会将 code 对象所包含的的信息存储在 pyc 文件内，下次运行直接加载 pyc 里的 code 对象到内存。 Python 解释器(interpreter)，同时拥有编译器和虚拟机的身份。具体流程参见PyCodeObject 包含 Python 虚拟机所需要的信息，而 pyc 就是其在硬盘实体化后的载体。 PyCodeObjectPyCodeObject，同样是 Python 对象，也继承 PyObject_HEAD。对于 Python 源代码中的任一 Code Block 都会创建一个 CodeObject 与之对应。一个新的命名空间，是一个 Code Block。类、函数、module都对应一个新的命名空间。 12345678910111213141516171819202122232425262728293031typedef struct &#123; PyObject_HEAD int co_argcount; /* 位置参数 *args 个数 */ int co_kwonlyargcount; /* #keyword only arguments */ int co_nlocals; /* 局部变量个数，包含位置参数 */ int co_stacksize; /* 需要的栈空间 */ int co_flags; /* 对block进行划分，详见 inspect.rst */ int co_firstlineno; /* 对应 .py 的起始行 */ PyObject *co_code; /* 字节码序列，PyStringObject 形式 */ PyObject *co_consts; /* list (所有常量) */ PyObject *co_names; /* list of strings (所有符号) */ PyObject *co_varnames; /* tuple of strings (局部变量名) */ PyObject *co_freevars; /* tuple of strings 使用了外层作用域中的变量名 */ PyObject *co_cellvars; /* tuple of strings 嵌套函数中使用了的变量名 */ /* 除了 co_name，余下都不用于 hash 或 比较。 为了回溯和debug，保留行号和名字。 否则，会不断的 覆盖已有的同名 func/lambda */ unsigned char *co_cell2arg; /* Maps cell vars which are arguments. */ PyObject *co_filename; /* unicode (.py 文件名) */ PyObject *co_name; /* unicode (函数名/类名/模块名) */ PyObject *co_lnotab; /* string (encoding addr&lt;-&gt;lineno mapping 字节码指令与 .py 行号的对应关系) */ void *co_zombieframe; /* for optimization only (see frameobject.c) */ PyObject *co_weakreflist; /* to support weakrefs to code objects */ /* Scratch space for extra data relating to the code object. */ void *co_extra;&#125; PyCodeObject; 需要注意的是，co_lnotab 记录行号，在实际中是记录增量值。 生成1234567891011121314151617&gt;&gt;&gt; src = open('demo.py').read()&gt;&gt;&gt; co = compile(src,'demo.py','exec')&gt;&gt;&gt; co&lt;code object &lt;module&gt; at 0x000002942853DD20, file "demo.py", line 1&gt;&gt;&gt;&gt; type(co)&lt;class 'code'&gt;&gt;&gt;&gt; co.co_consts(&lt;code object A , file "demo.py", line 1&gt;, 'A', &lt;code object fun, file "demo.py", line 5&gt;, 'fun', None)&gt;&gt;&gt; cls_A = co.co_consts[0]&gt;&gt;&gt; type(cls_A)&lt;class 'code'&gt;&gt;&gt;&gt; co.co_names('A', 'fun', 'a')&gt;&gt;&gt; co.co_filename'demo.py'&gt;&gt;&gt; cls_A.co_filename'demo.py' 可见，PyObjectObject 通过 co_consts 字段，实现了嵌套。 字节码123456// opcode.h#define POP_TOP 1#define ROT_TWO 2 ...#define HAVE_ARGUMENT 90#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT) opcode.h中定义了所有的字节码指令，判断是否需要参数是根据HAVE_ARGUMENT宏来简单判断 1234567891011&gt;&gt;&gt; cls_A&lt;code object A , file "demo.py", line 1&gt;&gt;&gt;&gt; import dis&gt;&gt;&gt; dis.dis(cls_A) 1 0 LOAD_NAME 0 (__name__) 2 STORE_NAME 1 (__module__) 4 LOAD_CONST 0 ('A') 6 STORE_NAME 2 (__qualname__) 2 8 LOAD_CONST 1 (None) 10 RETURN_VALUE dis 工具能很好的解析字节码： 第一列：字节码对应源码中的行号 第二列：当前字节码指令在 co_code 中的偏移位置 第三列：当前字节码指令 第四列：oparg，指令参数 最后一列：当前字节码指令的参数实际内容 栈帧 Python 解释器，本身拥有一套运行时的栈帧。但要执行源代码中的函数调用，却不是通过系统栈帧实现。在前文介绍 PyObject 时也发现，所有的 Object 都是存储在堆中。PyCodeObject 包含了运行时需要的信息，而其本身也存储在堆中。 因此，Python 在初始化后，会创建一个执行环境。发生函数调用时，会再次创建一个执行环境，并加载新的 PyCodeObject。这个执行环境，就是 PyFrameObject。关于函数调用的内容，会在 Pythn函数机制 中讲到。 12345678910111213141516171819202122/* Stack frames 快速的创建和释放，下面是一些加速手段： 1. Hold a single "zombie" frame on each code object. In zombie mode, 不持有 对象引用，但以下字段依然有效： * ob_type, ob_size, f_code, f_valuestack; * f_locals, f_trace, f_exc_type, f_exc_value, f_exc_traceback are NULL; * f_localsplus does not require re-allocation and the local variables in f_localsplus are NULL. 2. 共享池技术 free list，池中的 FrameObject，只有以下字段有效： ob_type == &amp;Frametype f_back next item on free list, or NULL f_stacksize size of value stack ob_size size of localsplus Note that the value and block stacks are preserved. 不同于整数对象池，此处的 frame object 是具有内存空间的。 PyFrame_MAXFREELIST(200) 限制了最大 free_list 数目*/ 共享池真是无处不在… PyFrameObject12345678910111213141516171819202122232425262728293031323334// frameobject.h.11typedef struct &#123; int b_type; /* what kind of block this is */ int b_handler; /* where to jump to find handler */ int b_level; /* value stack level to pop to */&#125; PyTryBlock;typedef struct _frame &#123; PyObject_VAR_HEAD struct _frame *f_back; /* previous frame, or NULL */ PyCodeObject *f_code; /* PyCodeObject 对象 */ PyObject *f_builtins; /* builtin symbol table (PyDictObject) */ PyObject *f_globals; /* global symbol table (PyDictObject) */ PyObject *f_locals; /* local symbol table (any mapping) */ PyObject **f_valuestack; /* 运行时栈 栈底 */ PyObject **f_stacktop; /* 运行时栈 栈顶 */ PyObject *f_trace; /* Trace function */ /* 用于 generator 交换错误信息 */ PyObject *f_exc_type, *f_exc_value, *f_exc_traceback; /* Borrowed reference to a generator, or NULL */ PyObject *f_gen; int f_lasti; /* 上一条字节码指令在 f_code 中的偏移位置 */ int f_lineno; /* 当前字节码，对应源代码行号 通过 PyFrame_GetLineNumber() 调用*/ int f_iblock; /* index in f_blockstack */ char f_executing; /* whether the frame is still executing */ PyTryBlock f_blockstack[CO_MAXBLOCKS]; /* for try and loop blocks */ PyObject *f_localsplus[1]; /* locals+stack, dynamically sized */&#125; PyFrameObject; f_back 表明 FrameObject 被组成链式结构，可以回溯，形成类似栈帧一样的结构。 PyFrame_New123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384PyFrameObject *PyFrame_New(PyThreadState *tstate, PyCodeObject *code, PyObject *globals, PyObject *locals)&#123; PyFrameObject *back = tstate-&gt;frame; PyFrameObject *f; PyObject *builtins; Py_ssize_t i; // 存在函数调用 if (back == NULL || back-&gt;f_globals != globals) &#123; // 获取 builtins （略） &#125; else &#123; /* share the globals、 builtins. Save a lookup and a call. */ builtins = back-&gt;f_builtins; assert(builtins != NULL); Py_INCREF(builtins); &#125; // 尝试利用 zombieframe if (code-&gt;co_zombieframe != NULL) &#123; f = code-&gt;co_zombieframe; code-&gt;co_zombieframe = NULL; _Py_NewReference((PyObject *)f); assert(f-&gt;f_code == code); &#125; else &#123; Py_ssize_t extras, ncells, nfrees; ncells = PyTuple_GET_SIZE(code-&gt;co_cellvars); // 闭包：嵌套函数，使用了的变量 nfrees = PyTuple_GET_SIZE(code-&gt;co_freevars); // 使用了的外部作用域变量。 // Frame 所需动态内存大小 extras = code-&gt;co_stacksize + \ // 运行，栈空间（系统级） code-&gt;co_nlocals + \ // 局部变量个数 ncells + \ nfrees; if (free_list == NULL) &#123; f = PyObject_GC_NewVar(PyFrameObject, &amp;PyFrame_Type, extras); &#125; else &#123; assert(numfree &gt; 0); // 熟悉的套路， 链表，而不是数组 --numfree; f = free_list; free_list = free_list-&gt;f_back; if (Py_SIZE(f) &lt; extras) &#123; // 触发 resize 调整大小 PyFrameObject *new_f = PyObject_GC_Resize(PyFrameObject, f, extras); f = new_f; &#125; _Py_NewReference((PyObject *)f); &#125; // 封装属性 f-&gt;f_code = code; // 此处，计算初始化时的栈顶 extras = code-&gt;co_nlocals + ncells + nfrees; f-&gt;f_valuestack = f-&gt;f_localsplus + extras; // 栈底 for (i=0; i&lt;extras; i++) f-&gt;f_localsplus[i] = NULL; f-&gt;f_locals = NULL; f-&gt;f_trace = NULL; f-&gt;f_exc_type = f-&gt;f_exc_value = f-&gt;f_exc_traceback = NULL; &#125; //封装属性 f-&gt;f_stacktop = f-&gt;f_valuestack; // 初始化的 Frame，栈顶==栈底 f-&gt;f_builtins = builtins; Py_XINCREF(back); f-&gt;f_back = back; Py_INCREF(code); Py_INCREF(globals); f-&gt;f_globals = globals; // 处理 f-&gt;f_locals (略) f-&gt;f_lasti = -1; f-&gt;f_lineno = code-&gt;co_firstlineno; f-&gt;f_iblock = 0; f-&gt;f_executing = 0; f-&gt;f_gen = NULL; _PyObject_GC_TRACK(f); return f;&#125; 创建 FrameObject 时，多创建了一部分作为运行时的栈空间。具体参考代码和下图： 获取FrameObject1234567891011121314151617# import sys; sys._getframe()import inspectdef f(): frame = inspect.currentframe() print(f"Current fun: &#123;frame.f_code.co_name&#125;") caller = frame.f_back print(f"Caller fun: &#123;caller.f_code.co_name&#125;") print(f"Caller's local: &#123;caller.f_locals&#125;") print(f"Caller's global: &#123;caller.f_globals.keys()&#125;")def c(): l = 1 m = 2 f()def show(): c() 结果显示，在被调用者中，完全可以通过 frame 链，获取到调用者的相关信息：123456show()Current fun: fCaller fun: cCaller fun: cCaller&apos;s local: &#123;&apos;m&apos;: 2, &apos;l&apos;: 1&#125;Caller&apos;s global: dict_keys([..., &apos;inspect&apos;, &apos;f&apos;, &apos;c&apos;, &apos;show&apos;]) 作用域Python 具有静态作用域，支持嵌套作用域，名字访问时按照LEGB规则访问属性。 Python 自身定义了一个 builtin 作用域，module 对应一个全局作用域 global，函数对应 local 作用域。这三个组成了LGB顺序查找模式。E 为 encloseing 的缩写，代表直接外围作用域，适用于函数闭包。 用名字访问时，用户代码的终点是 module，而 module 是在 import 编译完成时就已经确定了，所以永远不可能访问到其他 module 的相同名字，不会越界。 因为最内嵌套作用域的原因，决定 Python 行为的更多是代码出现的位置，而非执行的时间。 PyEval_EvalFrameEx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// ceval.c.750PyObject *PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)&#123; PyThreadState *tstate = PyThreadState_GET(); return tstate-&gt;interp-&gt;eval_frame(f, throwflag);&#125;// pystate.c.70PyInterpreterState * PyInterpreterState_New(void)&#123; ... interp-&gt;eval_frame = _PyEval_EvalFrameDefault; ...&#125;// ceval.c.757PyObject *_PyEval_EvalFrameDefault(PyFrameObject *f, int throwflag)&#123; int opcode; /* Current opcode */ int oparg; /* Current opcode argument, if any */ enum why_code why; /* Reason for block stack unwind */ PyThreadState *tstate = PyThreadState_GET(); ... tstate-&gt;frame = f; // 设置线程状态中的栈帧对象 co = f-&gt;f_code; names = co-&gt;co_names; consts = co-&gt;co_consts; fastlocals = f-&gt;f_localsplus; freevars = f-&gt;f_localsplus + co-&gt;co_nlocals; first_instr = (_Py_CODEUNIT *) PyBytes_AS_STRING(co-&gt;co_code); next_instr = first_instr; stack_pointer = f-&gt;f_stacktop; f-&gt;f_stacktop = NULL; /* remains NULL unless yield suspends frame */ ... // ceval.c.1144 for (;;) &#123; // ceval.c.1267 switch (opcode) &#123; TARGET(LOAD_FAST) &#123; ... &#125; TARGET(LOAD_CONST) &#123; ... &#125; ... &#125; &#125;&#125; PEP 523中引入了 _PyEval_EvalFrameDefault，具体的逻辑都在其中。在 for 循环中，不断遍历字节码序列，然后 switch 执行。遍历过程中： first_instr，始终指向字节码开始位置 next_inster，始终指向下一条待执行的位置（因参数影响，位置不固定） frame.f_lasti，始终指向已经执行的上一条的位置 通过判断 why/why_not 字段，决定循环的状态。12345678910/* Status code for main loop (reason for stack unwind) */enum why_code &#123; WHY_NOT = 0x0001, /* No error */ WHY_EXCEPTION = 0x0002, /* Exception occurred */ WHY_RETURN = 0x0008, /* 'return' statement */ WHY_BREAK = 0x0010, /* 'break' statement */ WHY_CONTINUE = 0x0020, /* 'continue' statement */ WHY_YIELD = 0x0040, /* 'yield' operator */ WHY_SILENCED = 0x0080 /* Exception silenced by 'with' */&#125;;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyCodeObject</tag>
        <tag>PyFrameObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】PyDictObject]]></title>
    <url>%2F2018%2F07%2F15%2F1.4.Python%E5%AD%97%E5%85%B8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[参考 python.org文档 PEP412 《Python源码剖析》—— 陈儒 InterfacePython官网把 PyDictObject 归类与 Concrete Objects Layer，享受同样待遇的还有PySetObject。在前面 PythonUnicodeObject 中，我们已经见到了 PythonDict 的运用，即共享机制 interned。在 Python 世界里，字典被用于建立字节码的运行环境，用来存放变量名和变量值，意味着做任何操作几乎都要设计到 PythonDict， 因此，对搜索的效率要求及其苛刻。因而采用的 HashTable(散列表)，在最优情况下能达到O(1)。散列表的基本思想是，将键映射为一个整数，把整数作为索引访问内存。主要逻辑是：查询键值 ——散列函数 hash function —— 散列值 hash value —— 内存区域 —— 查询结果——散列冲突。Python 处理散列冲突的问题，采用的是 开放定址法。删除探测链上元素，采用的是伪删除。 因为字典的重要性，Python 甚至单独在Objects/dictnotes.txt中写入了关于字典的说明，下面仅挑选部分内容：123456789101112131415161718192021222324252627281. 主要应用 1. 传递关键字参数（1~3个元素） 2. 类方法查找： 1. 通常包含 8~16 个元素。 2. 通常只写入一次，但多次查找 3. 当使用基类时，会频繁在基类中查找 3. 实例属性查找、全局变量查找 1. 通常包含 4~10 个元素。 2. 写入和读取都非常频繁 4. Builtins（内置命令） 1. 频繁的读取，几乎不写入 2. About 150 interned strings (as of Py3.3). 3. 其中一切访问频率远大于其他2. 数据存储 由3部分组成： 1. dictobject 自身 2. A dict-keys object (keys &amp; hashes) 3. A values array仅涉及单个键的字典操作可以是O（1），除非涉及到调整大小。现在的版本与之前的差别： 1. key value 可以分开存储 2. 分离表中 key-val 新增组合 (key, NULL)，代表被删除 3. key-val表中，不能嵌套小表 4. 一般字典比以前略大 5. 单个类的所有对象，共享key表，节约大量内存 PyDict_Type12345678910111213141516// dictobject.c.3282PyTypeObject PyDict_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "dict", sizeof(PyDictObject), (destructor)dict_dealloc, /* tp_dealloc */ &amp;dict_as_sequence, /* tp_as_sequence */ &amp;dict_as_mapping, /* tp_as_mapping */ PyObject_HashNotImplemented, /* tp_hash */ (getiterfunc)dict_iter, /* tp_iter */ mapp_methods, /* tp_methods */ dict_init, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ dict_new, /* tp_new */ PyObject_GC_Del, /* tp_free */&#125;; PyDictObject1234567891011121314151617181920212223// dictobject.h.18typedef struct _dictkeysobject PyDictKeysObject;typedef struct &#123; PyObject_HEAD /* Number of items in the dictionary */ Py_ssize_t ma_used; /* Dictionary version: globally unique, value change each time the dictionary is modified */ uint64_t ma_version_tag; PyDictKeysObject *ma_keys; /* If ma_values is NULL, the table is "combined": keys and values are stored in ma_keys. If ma_values is not NULL, the table is splitted: keys are stored in ma_keys and values are stored in ma_values */ PyObject **ma_values;&#125; PyDictObject; 如上，不同于之前的 PyListObject/PyUnicodeObject，他们被归类于 Sequence Object。而PyDictObject 归类于 Concrete Objects。因此，直接定义为 PyObject_HEAD。其他字段含义，见注释。 既然是分离设计，那么必然存在两个储存表的地方，一个是 ma_keys，一个是ma_values。具体内容见下文注释。1234567891011The DictObject can be in one of two forms.A combined table: ma_values == NULL, dk_refcnt == 1. Values are stored in the me_value field of the PyDictKeysObject.A split table: ma_values != NULL, dk_refcnt &gt;= 1 Values are stored in the ma_values array. Only string (unicode) keys are allowed. All dicts sharing same key must have same insertion order. PyDictKeysObject1234567891011121314// dict-common.h/23struct _dictkeysobject &#123; Py_ssize_t dk_refcnt; Py_ssize_t dk_size; dict_lookup_func dk_lookup; Py_ssize_t dk_usable; Py_ssize_t dk_nentries; union &#123; int8_t as_1[8]; int16_t as_2[4]; int32_t as_4[2]; int64_t as_8[1]; &#125; dk_indices;&#125;; PyDictKeysObject 实现了字典的 hash table，布局如下: layout1234567891011121314151617181920212223+---------------+| dk_refcnt || dk_size | /* Size of the hash table.| | It must be a power of 2. */| dk_lookup | /* Function to lookup in the hash table. */| dk_usable | /* Number of usable entries in dk_entries. */| dk_nentries | /* Number of used entries in dk_entries. */+---------------+| dk_indices | // Actual hash table of dk_size entries.| |+---------------+| dk_entries | /* array of PyDictKeyEntry.| | len(dk_entries) == USABLE_FRACTION(dk_size) */+---------------+The size in bytes of an indice depends on dk_size:- 1 byte if dk_size &lt;= 0xff (char*)- 2 bytes if dk_size &lt;= 0xffff (int16_t*)- 4 bytes if dk_size &lt;= 0xffffffff (int32_t*)- 8 bytes otherwise (int64_t*)Dynamically sized, 8 is minimum. 需要注意的是，dk_indices 是一个共用体，会根据 dk_size 的值，决定存储 index 的类型。 PyDictKeyEntry1234567891011// dict-common.h.17#define DKIX_EMPTY (-1)#define DKIX_DUMMY (-2) /* Used internally */#define DKIX_ERROR (-3)// dict-common.h.4typedef struct &#123; Py_hash_t me_hash; /* Cached hash code of me_key. */ PyObject *me_key; PyObject *me_value; /* only meaningful for combined tables */&#125; PyDictKeyEntry; dk_entries中存储的是 PyDictKeyEntry对象，其中每个元素都可以称为一个 enrty。因为使用了负数作为 entry 的状态，因此dk_indices中存储的是有符号整数。可以通过 宏 DK_ENTRIES 访问 entry：1234567891011// dictobject.c.289#define DK_SIZE(dk) ((dk)-&gt;dk_size)#define DK_IXSIZE(dk) \ (DK_SIZE(dk) &lt;= 0xff ? \ 1 : DK_SIZE(dk) &lt;= 0xffff ? \ 2 : DK_SIZE(dk) &lt;= 0xffffffff ? \ 4 : sizeof(int64_t))#define DK_ENTRIES(dk) \ ((PyDictKeyEntry*)(&amp;(dk)-&gt;dk_indices.as_1[DK_SIZE(dk) * DK_IXSIZE(dk)])) dk_indicesdk_indices 即是真正的 hash table，对应一个 slot 数组，每个slot 有四种状态1234567891011121314151617181920// dictobject.c.641. Unused. index == DKIX_EMPTY This is each slot's initial state. Does not hold an active (key, value) pair now and never did. Unused can transition to Active upon key insertion.2. Active. index &gt;= 0, me_key != NULL and me_value != NULL Holds an active (key, value) pair. This is the only case in which me_value != NULL. Active can transition to Dummy or Pending upon key deletion~~~~ (for combined and split tables respectively).3. Dummy. index == DKIX_DUMMY (combined only) Previously held an active (key, value) pair, but that was deleted and an active pair has not yet overwritten the slot. Dummy can transition to Active upon key insertion. Dummy slots cannot be made Unused again.4. Pending. index &gt;= 0, key != NULL, and value == NULL (split only) Not yet inserted in split-table. 简单来说就是 Unused，初始状态，该 slot 没有被使用，index = -1 Active，正在使用，index &gt; 0 Dummy，曾经使用过，但现在被删除了，index = -2 。(仅限 combined-table) Pending，还未插入。(仅限 split-table)正因为 Dummy 态不能转换为 Unused，所以保证了探测链的连续性，对应前文说的 伪删除。 创建12345678910#define PyDict_MINSIZE 8// dictobject.c.620PyObject * PyDict_New(void)&#123; PyDictKeysObject *keys = new_keys_object(PyDict_MINSIZE); if (keys == NULL) return NULL; return new_dict(keys, NULL);&#125; PyDict_MINSIZE 是任何新 Dict 的起始大小，默认为8，满足运行过程中大量的函数参数传递过程。 new_keys_object12345678910111213141516171819202122232425262728293031323334353637383940414243// dictobject.c.374#define USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)static PyDictKeysObject *new_keys_object(Py_ssize_t size)&#123; PyDictKeysObject *dk; Py_ssize_t es, usable; // dk_size &gt;= 8 and must be a power of 2. assert(size &gt;= PyDict_MINSIZE); assert(IS_POWER_OF_2(size)); // len(dk_entries) == USABLE_FRACTION(dk_size)，最小为5 usable = USABLE_FRACTION(size); ... // es = 1/2/3/4; 根据 size 大小，确定存储位数 // 尝试共享 if (size == PyDict_MINSIZE &amp;&amp; numfreekeys &gt; 0) &#123; dk = keys_free_list[--numfreekeys]; &#125; else &#123; dk = PyObject_MALLOC(sizeof(PyDictKeysObject) - Py_MEMBER_SIZE(PyDictKeysObject, dk_indices) + es * size + sizeof(PyDictKeyEntry) * usable); if (dk == NULL) &#123; PyErr_NoMemory(); return NULL; &#125; &#125; DK_DEBUG_INCREF dk-&gt;dk_refcnt = 1; dk-&gt;dk_size = size; dk-&gt;dk_usable = usable; dk-&gt;dk_lookup = lookdict_unicode_nodummy; dk-&gt;dk_nentries = 0; // 初始化 dk_indices == -1 memset(&amp;dk-&gt;dk_indices.as_1[0], 0xff, es * size); // 初始化 dk_entries == 0 memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable); return dk;&#125; 从代码中也清晰的看见，对象缓冲池 keys_free_list 的身影。其中需要注意的是： 1usable = USABLE_FRACTION(size); // (((n) &lt;&lt; 1)/3) size 默认为 PyDict_MINSIZE 即8。通过计算可以得出默认存放5个对象。 new_dict1234567891011121314151617181920212223242526// dictobject.c.573static PyObject *new_dict(PyDictKeysObject *keys, PyObject **values)&#123; PyDictObject *mp; // 尝试共享 if (numfree) &#123; mp = free_list[--numfree]; _Py_NewReference((PyObject *)mp); &#125; else &#123; mp = PyObject_GC_New(PyDictObject, &amp;PyDict_Type); if (mp == NULL) &#123; DK_DECREF(keys); free_values(values); return NULL; &#125; &#125; mp-&gt;ma_keys = keys; mp-&gt;ma_values = values; mp-&gt;ma_used = 0; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); return (PyObject *)mp;&#125; 代码不长，很好懂。再次发现了对象池 free_list。 共享机制前面 创建 PyDictObject 和 PyDictKeysObject 时，都利用了对象缓冲池。12345#define PyDict_MAXFREELIST 80static PyDictObject *free_list[PyDict_MAXFREELIST];static int numfree = 0;static PyDictKeysObject *keys_free_list[PyDict_MAXFREELIST];static int numfreekeys = 0; 宏定义如上，与 PyListObject 类似，甚至连名字都类似。那么必然的，销毁对象时，会把对象放入缓冲池。 dict_dealloc1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static PyObject *empty_values[1] = &#123; NULL &#125;;// dictobject.c.2003static void dict_dealloc(PyDictObject *mp)&#123; PyObject **values = mp-&gt;ma_values; PyDictKeysObject *keys = mp-&gt;ma_keys; Py_ssize_t i, n; /* bpo-31095: UnTrack is needed before calling any callbacks */ PyObject_GC_UnTrack(mp); Py_TRASHCAN_SAFE_BEGIN(mp) if (values != NULL) &#123; if (values != empty_values) &#123; for (i = 0, n = mp-&gt;ma_keys-&gt;dk_nentries; i &lt; n; i++) &#123; Py_XDECREF(values[i]); &#125; free_values(values); &#125; DK_DECREF(keys); &#125; else if (keys != NULL) &#123; assert(keys-&gt;dk_refcnt == 1); DK_DECREF(keys); &#125; // 尝试共享 if (numfree &lt; PyDict_MAXFREELIST &amp;&amp; Py_TYPE(mp) == &amp;PyDict_Type) free_list[numfree++] = mp; else Py_TYPE(mp)-&gt;tp_free((PyObject *)mp); Py_TRASHCAN_SAFE_END(mp)&#125;// dictobject.c.554static void free_keys_object(PyDictKeysObject *keys)&#123; PyDictKeyEntry *entries = DK_ENTRIES(keys); Py_ssize_t i, n; for (i = 0, n = keys-&gt;dk_nentries; i &lt; n; i++) &#123; Py_XDECREF(entries[i].me_key); Py_XDECREF(entries[i].me_value); &#125; // 尝试共享 if (keys-&gt;dk_size == PyDict_MINSIZE &amp;&amp; numfreekeys &lt; PyDict_MAXFREELIST) &#123; keys_free_list[numfreekeys++] = keys; return; &#125; PyObject_FREE(keys);&#125; CRUDMapping方法簇12345678910static PyMappingMethods dict_as_mapping = &#123; (lenfunc)dict_length, /*mp_length*/ (binaryfunc)dict_subscript, /*mp_subscript*/ (objobjargproc)dict_ass_sub, /*mp_ass_subscript*/&#125;;static Py_ssize_t dict_length(PyDictObject *mp)&#123; return mp-&gt;ma_used;&#125; PyDict_Type 中定义的 tp_as_mapping == &amp;dict_as_mapping。从代码中可以看见len(dict)时间复杂度为O(1)。执行 dict[item] 即调用 dict_subscript()。 GetItem12345678910111213141516171819202122232425262728293031323334353637383940414243// dictobject.c.2172static PyObject * dict_subscript(PyDictObject *mp, PyObject *key)&#123; PyObject *v; Py_ssize_t ix; Py_hash_t hash; PyObject **value_addr; // 1. 获取/计算 hash 值 if (!PyUnicode_CheckExact(key) || (hash = ((PyASCIIObject *) key)-&gt;hash) == -1) &#123; hash = PyObject_Hash(key); if (hash == -1) return NULL; &#125; // 2. 查找 index ，返回 ix&gt;0 或 ix == -1 / -3 ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;value_addr, NULL); if (ix == DKIX_ERROR) // -3 return NULL; // 3. 根据 ix 结果值，执行 __miss__ 或 返回结果 if (ix == DKIX_EMPTY || *value_addr == NULL) &#123; if (!PyDict_CheckExact(mp)) &#123; /* Look up __missing__ method if we're a subclass. */ PyObject *missing, *res; _Py_IDENTIFIER(__missing__); missing = _PyObject_LookupSpecial((PyObject *)mp, &amp;PyId___missing__); if (missing != NULL) &#123; res = PyObject_CallFunctionObjArgs(missing, key, NULL); Py_DECREF(missing); return res; &#125; else if (PyErr_Occurred()) return NULL; &#125; _PyErr_SetKeyError(key); return NULL; &#125; v = *value_addr; Py_INCREF(v); return v;&#125; 源码如上，需要注意的的是，返回的是 对象引用。并且，时间复杂度为O(1)。 ix 获取方式 mp-&gt;ma_keys-&gt;dk_lookup，即调用 PyDictObject 自身的 dk_lookup，在前面的 PyDict_New 中，可以发现 dk-&gt;dk_lookup = lookdict_unicode_nodummy。实际上，dk_lookup 存在不止一种。 dk_lookup123456789101112131415161718192021222324252627// ictobject.c.224/* lookdict() is general-purpose, and may return DKIX_ERROR if (and only if) a comparison raises an exception. */static Py_ssize_t lookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos);/* Specialized version for string-only keys */static Py_ssize_t lookdict_unicode(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos);/* Faster version of lookdict_unicode when it is known that no &lt;dummy&gt; keys * will be present. */static Py_ssize_tlookdict_unicode_nodummy(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos);/* Version of lookdict for split tables. * All split tables and only split tables use this lookup function. * Split tables only contain unicode keys and no dummy keys, * so algorithm is the same as lookdict_unicode_nodummy. */static Py_ssize_t lookdict_split(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos); 如上，dk_lookup 有4个非常相似的 查找函数。因为在 Python 中，大量使用 str 作为字典的 key，因此会有2个特定针对 str 对象的 优化版本。 lookdict123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113static Py_ssize_tlookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos)&#123; size_t i, mask; Py_ssize_t ix, freeslot; int cmp; PyDictKeysObject *dk; PyDictKeyEntry *ep0, *ep; PyObject *startkey;top: dk = mp-&gt;ma_keys; mask = DK_MASK(dk); ep0 = DK_ENTRIES(dk); i = (size_t)hash &amp; mask; ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) *hashpos = i; *value_addr = NULL; return DKIX_EMPTY; &#125; if (ix == DKIX_DUMMY) &#123; freeslot = i; &#125; else &#123; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125; freeslot = -1; &#125; for (size_t perturb = hash;;) &#123; perturb &gt;&gt;= PERTURB_SHIFT; i = ((i &lt;&lt; 2) + i + perturb + 1) &amp; mask; ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) &#123; *hashpos = (freeslot == -1) ? (Py_ssize_t)i : freeslot; &#125; *value_addr = NULL; return ix; &#125; if (ix == DKIX_DUMMY) &#123; if (freeslot == -1) freeslot = i; continue; &#125; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125; &#125; assert(0); /* NOT REACHED */ return 0;&#125; 如上，通用的 lookdict 代码很长。大概可以分为 以下几部分 ix = ?12345678910111213#define DK_MASK(dk) (((dk)-&gt;dk_size)-1)static Py_ssize_tlookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos)&#123; size_t i, mask; PyDictKeysObject *dk; dk = mp-&gt;ma_keys; mask = DK_MASK(dk); i = (size_t)hash &amp; mask; // hash%dk_size == hash &amp; (dk_size - 1)&#125; 前面已经知道： hash == PyObject_Hash(key) dk_size &gt;= 8 &amp;&amp; IS_POWER_OF_2 注意最后一行，将 hash 值映射到数组上 if ix == DKIX_EMPTY1234567891011121314static Py_ssize_tlookdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject ***value_addr, Py_ssize_t *hashpos)&#123; /* lookup indices. returns DKIX_EMPTY, DKIX_DUMMY, or ix &gt;=0 */ ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) *hashpos = i; *value_addr = NULL; return DKIX_EMPTY; &#125;&#125; 如上，当 ix == DKIX_EMPTY 表明，slot 可用，直接返回。需要注意的是，返回之前，把 *value_addr 设为了 NULL，相当于清空了数据。 if ix != DKIX_EMPTY123456789101112131415161718192021222324252627282930313233343536373839404142PyDictKeyEntry *ep0, *ep;// DK_ENTRIES(keys)[index] if index &gt;= 0ep0 = DK_ENTRIES(dk);if (ix == DKIX_DUMMY) &#123; freeslot = i; // 伪删除，me_value==NULL&#125;else &#123; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; // 引用相同 *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; // hash 相同 startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); /* cmp = startkey == key ? 1 : 0 or -1 (raise ERROR) */ Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; // 值相同 *value_addr = &amp;ep-&gt;me_value; if (hashpos != NULL) *hashpos = i; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125; freeslot = -1;&#125; 如上，当 ix == DKIX_DUMMY 时，将 freeslot 设置为该 slot。若后续搜索没有成功找到，那么将返回该 slot。 当 ix&gt;=0 &amp;&amp; ix != DKIX_DUMMY 时，获取 Entry 对象，对其值进行判断。前面已经知道，me_hash 是 hash(me_key) 的 缓存。 接着两个 if 判断，是为了优先考虑引用相同，接着再考虑引用不同而值相同。因为 Python 内部存在对象缓冲池，小整数，字符串等具有相同的对象引用，而对于1024等大整数，就必须判断 引用不一样而值一样。 PyObject_RichCompareBool 是传入操作数与操作符，返回数值。 若cmp==1，即 hash,value 都相等，正确返回。 若cmp==0，即 hash相等，值不等，即 hash 冲突。 解决 hash 冲突123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*执行循环的 前提条件：if ix == DKIX_DUMMY： freeslot = ielif ix&gt;=0 and hash冲突: freeslot = -1;*/#define PERTURB_SHIFT 5for (size_t perturb = hash;;) &#123; // 探测链算法 perturb &gt;&gt;= PERTURB_SHIFT; i = ((i &lt;&lt; 2) + i + perturb + 1) &amp; mask; ix = dk_get_index(dk, i); if (ix == DKIX_EMPTY) &#123; if (hashpos != NULL) &#123; *hashpos = (freeslot == -1) ? (Py_ssize_t)i : freeslot; /* 找到一个 UnusedEnpty，表明搜索失败 1. freeslot 不存在，返回现在的 2. freeslot 已经有一个，返回第一个 */ &#125; *value_addr = NULL; return ix; &#125; if (ix == DKIX_DUMMY) &#123; // 探测链 继续寻找 if (freeslot == -1) freeslot = i; continue; &#125; ep = &amp;ep0[ix]; assert(ep-&gt;me_key != NULL); if (ep-&gt;me_key == key) &#123; // 引用相同 if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; if (ep-&gt;me_hash == hash) &#123; startkey = ep-&gt;me_key; Py_INCREF(startkey); cmp = PyObject_RichCompareBool(startkey, key, Py_EQ); Py_DECREF(startkey); if (cmp &lt; 0) &#123; *value_addr = NULL; return DKIX_ERROR; &#125; if (dk == mp-&gt;ma_keys &amp;&amp; ep-&gt;me_key == startkey) &#123; if (cmp &gt; 0) &#123; // 值相同 if (hashpos != NULL) &#123; *hashpos = i; &#125; *value_addr = &amp;ep-&gt;me_value; return ix; &#125; &#125; else &#123; /* The dict was mutated, restart */ goto top; &#125; &#125;&#125; 如上，整个过程是，当发生冲突时，再次计算获取一个 i 值，最终返回 NUll 或 目标值。 SetItemdict_ass_sub123456789101112131415161718192021222324252627282930313233343536// dictobject.c.2163static intdict_ass_sub(PyDictObject *mp, PyObject *v, PyObject *w)&#123; if (w == NULL) return PyDict_DelItem((PyObject *)mp, v); else return PyDict_SetItem((PyObject *)mp, v, w);&#125;// dictobject.c.1554intPyDict_SetItem(PyObject *op, PyObject *key, PyObject *value)&#123; PyDictObject *mp; Py_hash_t hash; // 类型检查 if (!PyDict_Check(op)) &#123; PyErr_BadInternalCall(); return -1; &#125; assert(key); assert(value); mp = (PyDictObject *)op; // 获取 hash 值 if (!PyUnicode_CheckExact(key) || (hash = ((PyASCIIObject *) key)-&gt;hash) == -1) &#123; hash = PyObject_Hash(key); if (hash == -1) return -1; &#125; /* insertdict() handles any resizing that might be necessary */ return insertdict(mp, key, hash, value);&#125; 执行 dict[item] = value 时，调用 dict_ass_sub()。如上，与 List 类似，SetItem 和 DelItem 都是调用同一个方法。在 PyDict_SetItem 中，仅进行类型检查，计算 hash 值，实际插入调用 insertdict。 insertdict12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// dictobject.c.1110static intinsertdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value)&#123; PyObject *old_value; PyObject **value_addr; PyDictKeyEntry *ep, *ep0; Py_ssize_t hashpos, ix; Py_INCREF(key); Py_INCREF(value); // split-table 插入 key(not Unicode) if (mp-&gt;ma_values != NULL &amp;&amp; !PyUnicode_CheckExact(key)) &#123; if (insertion_resize(mp) &lt; 0) goto Fail; &#125; // 计算 ix 的值 ix = ? ix = mp-&gt;ma_keys-&gt;dk_lookup(mp, key, hash, &amp;value_addr, &amp;hashpos); if (ix == DKIX_ERROR) goto Fail; assert(PyUnicode_CheckExact(key) || mp-&gt;ma_keys-&gt;dk_lookup == lookdict); MAINTAIN_TRACKING(mp, key, value); // split-table 插入 key(different order) if (_PyDict_HasSplitTable(mp) &amp;&amp; ((ix &gt;= 0 &amp;&amp; *value_addr == NULL &amp;&amp; mp-&gt;ma_used != ix) || (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123; if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); ix = DKIX_EMPTY; &#125; // Insert when ix == DKIX_EMPTY if (ix == DKIX_EMPTY) &#123; /* Insert into new slot. */ if (mp-&gt;ma_keys-&gt;dk_usable &lt;= 0) &#123; /* Need to resize. */ if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); &#125; ep0 = DK_ENTRIES(mp-&gt;ma_keys); ep = &amp;ep0[mp-&gt;ma_keys-&gt;dk_nentries]; dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries); ep-&gt;me_key = key; ep-&gt;me_hash = hash; if (mp-&gt;ma_values) &#123; assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == NULL); mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value; &#125; else &#123; ep-&gt;me_value = value; &#125; mp-&gt;ma_used++; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); mp-&gt;ma_keys-&gt;dk_usable--; mp-&gt;ma_keys-&gt;dk_nentries++; assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= 0); assert(_PyDict_CheckConsistency(mp)); return 0; &#125; assert(value_addr != NULL); // Insert when ix != DKIX_EMPTY old_value = *value_addr; if (old_value != NULL) &#123; *value_addr = value; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); assert(_PyDict_CheckConsistency(mp)); Py_DECREF(old_value); /* which **CAN** re-enter (see issue #22653) */ Py_DECREF(key); return 0; &#125; /* pending state */ assert(_PyDict_HasSplitTable(mp)); assert(ix == mp-&gt;ma_used); *value_addr = value; mp-&gt;ma_used++; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); assert(_PyDict_CheckConsistency(mp)); Py_DECREF(key); return 0;Fail: Py_DECREF(value); Py_DECREF(key); return -1;&#125; 如上，实际插入的对象的函数，代码也很长，需要分块处理。 split-table 插入 key(not Unicode)1234if (mp-&gt;ma_values != NULL &amp;&amp; !PyUnicode_CheckExact(key)) &#123; if (insertion_resize(mp) &lt; 0) goto Fail;&#125; 在 前面 PyDictObject 结构体定义中，有提到：1234A split table: ma_values != NULL, dk_refcnt &gt;= 1 Values are stored in the ma_values array. Only string (unicode) keys are allowed. 当，split table 插入的 key 不是 Unicode 时，调用 insertion_resize。 split-table 插入 key(different order)1234567891011/* When insertion order is different from shared key, we can't share * the key anymore. Convert this instance to combine table. */if (_PyDict_HasSplitTable(mp) &amp;&amp; ((ix &gt;= 0 &amp;&amp; *value_addr == NULL &amp;&amp; mp-&gt;ma_used != ix) || (ix == DKIX_EMPTY &amp;&amp; mp-&gt;ma_used != mp-&gt;ma_keys-&gt;dk_nentries))) &#123; if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); ix = DKIX_EMPTY;&#125; 在 前面 PyDictObject 结构体定义中，同时有提到：12A split table: All dicts sharing same key must have same insertion order. 如源码中注释所述，当插入 顺序不一致时，将调用 insertion_resize。 Insert when ix == DKIX_EMPTY123456789101112131415161718192021222324252627282930313233if (ix == DKIX_EMPTY) &#123; /* Insert into new slot. */ if (mp-&gt;ma_keys-&gt;dk_usable &lt;= 0) &#123; /* Need to resize. */ if (insertion_resize(mp) &lt; 0) goto Fail; find_empty_slot(mp, key, hash, &amp;value_addr, &amp;hashpos); &#125; // 初始化 ep0 = DK_ENTRIES(mp-&gt;ma_keys); ep = &amp;ep0[mp-&gt;ma_keys-&gt;dk_nentries]; dk_set_index(mp-&gt;ma_keys, hashpos, mp-&gt;ma_keys-&gt;dk_nentries); ep-&gt;me_key = key; ep-&gt;me_hash = hash; // 插入不同地方 if (mp-&gt;ma_values) &#123; assert (mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] == NULL); mp-&gt;ma_values[mp-&gt;ma_keys-&gt;dk_nentries] = value; &#125; else &#123; ep-&gt;me_value = value; &#125; // 调整属性值 mp-&gt;ma_used++; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); mp-&gt;ma_keys-&gt;dk_usable--; mp-&gt;ma_keys-&gt;dk_nentries++; assert(mp-&gt;ma_keys-&gt;dk_usable &gt;= 0); assert(_PyDict_CheckConsistency(mp)); return 0;&#125; 如上，ix == DKIX_EMPTY 时，执行插入动作。 if 可用空间 dk_usable &lt;=0，调用 insertion_resize dk_set_index，初始化 me_key, me_hash 根据 ma_values，判断 table 类型，插入 不同的地方 调整 mp 自身属性 Insert when ix != DKIX_EMPTY123456789101112131415161718192021assert(value_addr != NULL);old_value = *value_addr;if (old_value != NULL) &#123; *value_addr = value; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); assert(_PyDict_CheckConsistency(mp)); Py_DECREF(old_value); /* which **CAN** re-enter (see issue #22653) */ Py_DECREF(key); return 0;&#125;/* pending state */assert(_PyDict_HasSplitTable(mp));assert(ix == mp-&gt;ma_used);*value_addr = value;mp-&gt;ma_used++;mp-&gt;ma_version_tag = DICT_NEXT_VERSION();assert(_PyDict_CheckConsistency(mp));Py_DECREF(key);return 0; 如上，ix != DKIX_EMPTY 即代表修改值。同时，根据 old_value 可以判断出 表的类型。 PyDict_DelItem前面已经提到 Del 和 Set 有相同的入口 dict_ass_sub。Del 最终实现是靠 PyDict_DelItem()1234567891011121314// dictobject.c/1621int PyDict_DelItem(PyObject *op, PyObject *key)&#123; Py_hash_t hash; assert(key); if (!PyUnicode_CheckExact(key) || (hash = ((PyASCIIObject *) key)-&gt;hash) == -1) &#123; hash = PyObject_Hash(key); if (hash == -1) return -1; &#125; return _PyDict_DelItem_KnownHash(op, key, hash);&#125; 如上，先验证 hash，在调用 _PyDict_DelItem_KnownHash _PyDict_DelItem_KnownHash123456789101112131415161718192021222324252627282930313233int_PyDict_DelItem_KnownHash(PyObject *op, PyObject *key, Py_hash_t hash)&#123; Py_ssize_t hashpos, ix; PyDictObject *mp; PyObject **value_addr; if (!PyDict_Check(op)) &#123; PyErr_BadInternalCall(); return -1; &#125; assert(key); assert(hash != -1); mp = (PyDictObject *)op; ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;value_addr, &amp;hashpos); if (ix == DKIX_ERROR) return -1; if (ix == DKIX_EMPTY || *value_addr == NULL) &#123; _PyErr_SetKeyError(key); return -1; &#125; assert(dk_get_index(mp-&gt;ma_keys, hashpos) == ix); // Split table doesn't allow deletion. Combine it. if (_PyDict_HasSplitTable(mp)) &#123; if (dictresize(mp, DK_SIZE(mp-&gt;ma_keys))) &#123; return -1; &#125; ix = (mp-&gt;ma_keys-&gt;dk_lookup)(mp, key, hash, &amp;value_addr, &amp;hashpos); assert(ix &gt;= 0); &#125; return delitem_common(mp, hashpos, ix, value_addr);&#125; 如上，_PyDict_DelItem_KnownHash 代码很好理解，根据 key hash 找到相应的 enrty。需要注意的是其中的，Split-table 不允许删除操作，必然要转换为 combined table。 delitem_common1234567891011121314151617181920212223static intdelitem_common(PyDictObject *mp, Py_ssize_t hashpos, Py_ssize_t ix, PyObject **value_addr)&#123; PyObject *old_key, *old_value; PyDictKeyEntry *ep; old_value = *value_addr; assert(old_value != NULL); *value_addr = NULL; mp-&gt;ma_used--; mp-&gt;ma_version_tag = DICT_NEXT_VERSION(); ep = &amp;DK_ENTRIES(mp-&gt;ma_keys)[ix]; dk_set_index(mp-&gt;ma_keys, hashpos, DKIX_DUMMY); ENSURE_ALLOWS_DELETIONS(mp); old_key = ep-&gt;me_key; ep-&gt;me_key = NULL; Py_DECREF(old_key); Py_DECREF(old_value); assert(_PyDict_CheckConsistency(mp)); return 0;&#125; 如上，代码很简单。。就酱。。 insertion_resize123456// dictobject.c.1099static intinsertion_resize(PyDictObject *mp)&#123; return dictresize(mp, GROWTH_RATE(mp));&#125; 前面，已经提到，在 CRUD 时，有几种情况下会调用 insertion_resize dk_usable &lt;=0 split-table insert key which is not Unicode. split-table insertion order is different from shared key. GROWTH_RATE1#define GROWTH_RATE(d) (((d)-&gt;ma_used*2)+((d)-&gt;ma_keys-&gt;dk_size&gt;&gt;1)) 如上，在调用 dictresize 之前，会先计算一个 GROWTH_RATE。这个东西的作用可以参考链接已失效 123456789101112如果原有的数据量小于原有大小的1/4，那么它也会小于现有大小的1/4，但新的dict缩小了；如果原有的数据量大于原有大小的1/4，那么它也会大于现有大小的1/4，但新的dict扩大了。if used &lt; size/4: used*4 &lt; used*2 + size/4*2 = used*2 + size/2 = newsize used &lt; newsize/4 newsize = used*2 + size/2 &lt; size/4*2 + size/2 = sizeif used &gt; size/4: used*4 &gt; used*2 + size/4*2 = used*2 + size/2 = newsize used &gt; newsize/4 newsize = used*2 + size/2 &gt; size/4*2 + size/2 = size emmm…好吧，看看就好 dictresize123456789101112131415161718192021222324252627282930313233343536373839404142// dictobject.c.1250/* Restructure the table by allocating a new table and reinserting all items again. When entries have been deleted, the new table may actually be smaller than the old one. If a table is split (its keys and hashes are shared, its values are not), then the values are temporarily copied into the table, it is resized as a combined table, then the me_value slots in the old table are NULLed out. After resizing a table is always combined, but can be resplit by make_keys_shared().*/static intdictresize(PyDictObject *mp, Py_ssize_t minsize) ... // 很多很多 /* Allocate a new table. */ // 注：static PyDictKeysObject *new_keys_object(Py_ssize_t size) mp-&gt;ma_keys = new_keys_object(newsize); /* Main loop */ for (i = 0; i &lt; oldkeys-&gt;dk_nentries; i++) &#123; PyDictKeyEntry *ep = &amp;ep0[i]; if (ep-&gt;me_value != NULL) &#123; insertdict_clean(mp, ep-&gt;me_key, ep-&gt;me_hash, ep-&gt;me_value); &#125; &#125; ... // 很多很多&#125;/* Internal routine used by dictresize() to insert an item which is known to be absent from the dict. This routine also assumes that the dict contains no deleted entries. Besides the performance benefit, using insertdict() in dictresize() is dangerous (SF bug #1456209). Note that no refcounts are changed by this routine; if needed, the caller is responsible for incref'ing `key` and `value`. Neither mp-&gt;ma_used nor k-&gt;dk_usable are modified by this routine; the caller must set them correctly*/static voidinsertdict_clean(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value) emm…代码很长，看注释就够了。 dictresize 返回的都是 combined table，跟上文一致 combined split 两者是可以相互转换的 resize 后，表是可以被 扩容或缩小的 insertdict_clean 只干插入的活，不干其他的 只要涉及到 resize ，就涉及到 Malloc memcpy，耗时 耗力]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyDictObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】PyListObject]]></title>
    <url>%2F2018%2F07%2F15%2F1.3.Python%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[参考 python.org文档 interface123Another generally useful object type is a list of object pointers.This is a mutable type: the list items can be changed, and items can beadded or removed. Out-of-range indices or non-list objects are ignored. 老套路，开局一段注释： 对象指针列表 可以增删改查 具有索引容错功能 PyListObject123456789101112131415161718// listobject.h.23typedef struct &#123; PyObject_VAR_HEAD PyObject **ob_item; Py_ssize_t allocated;&#125; PyListObject;/* ob_item contains space for 'allocated' elements. The number * currently in use is ob_size. * Invariants: * 0 &lt;= ob_size &lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ 如上，其中的注释很有用，其他信息： **ob_item 明确是指针数组 allocated 标记了容器大小，决定了内存大小 ob_size 标记了元素个数 PyList_Type1234567891011// listobject.c.2624PyTypeObject PyList_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "list", sizeof(PyListObject), 0, (destructor)list_dealloc, /* tp_dealloc */ PyType_GenericAlloc, /* tp_alloc */ PyType_GenericNew, /* tp_new */ (initproc)list_init, /* tp_init */&#125;; 在之前的 PyLong_Type、PyUnicode_Type中，tp_new都是单独定义的函数。而在PyList_Type中，是通用的 PyType_Generic* 函数。下面，我们就来看下他们的逻辑。 PyType_GenericNew1234567891011121314151617181920212223242526272829303132333435363738394041424344// typeobject.c.958PyObject *PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)&#123; return type-&gt;tp_alloc(type, 0);&#125;// typeobject.c.928PyObject * PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)&#123; PyObject *obj; const size_t size = _PyObject_VAR_SIZE(type, nitems+1); /* note that we need to add one, for the sentinel */ if (PyType_IS_GC(type)) obj = _PyObject_GC_Malloc(size); else obj = (PyObject *)PyObject_MALLOC(size); if (obj == NULL)); return PyErr_NoMemory(); memset(obj, '\0', size); if (type-&gt;tp_flags &amp; Py_TPFLAGS_HEAPTYPE) Py_INCREF(type); if (type-&gt;tp_itemsize == 0) (void)PyObject_INIT(obj, type); else (void) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems); if (PyType_IS_GC(type)) _PyObject_GC_TRACK(obj); return obj;&#125;// objimpl.h.141/* Macros trading binary compatibility for speed. See also pymem.h. Note that these macros expect non-NULL object pointers.*/#define PyObject_INIT(op, typeobj) \ ( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )#define PyObject_INIT_VAR(op, typeobj, size) \ ( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) ) 如上，具体细节不在深究，能够看出一个轮廓： 根据 type 计算 size 根据 size 调用 MALLOC 调用 INIT 完成初始化 PyList_New123456789PyObject* PyList_New(Py_ssize_t len) Return value: New reference. Return a new list of length len on success, or NULL on failure. Note: If len is greater than zero, the returned list object’s items are set to NULL. Thus you cannot use abstract API functions such as PySequence_SetItem() or expose the object to Python code before setting all items to a real object with PyList_SetItem(). 上面，是来自来自文档的API介绍，其中介绍了创建列表，设置元素的方法。 12345678910111213141516171819202122232425262728293031323334353637383940// listobject.c.104#define PyList_MAXFREELIST 80static PyListObject *free_list[PyList_MAXFREELIST];static int numfree = 0;// listobject.c.140PyObject * PyList_New(Py_ssize_t size)&#123; PyListObject *op; // asert size &gt;= 0 if (size &lt; 0) &#123; PyErr_BadInternalCall(); return NULL; &#125; // 尝试共享 list 对象指针 if (numfree) &#123; numfree--; op = free_list[numfree]; _Py_NewReference((PyObject *)op); &#125; else &#123; op = PyObject_GC_New(PyListObject, &amp;PyList_Type); if (op == NULL) return NULL; &#125; // 获取真实数据地址 if (size &lt;= 0) op-&gt;ob_item = NULL; else &#123; op-&gt;ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *)); &#125; // 赋初值 Py_SIZE(op) = size; op-&gt;allocated = size; _PyObject_GC_TRACK(op); return (PyObject *) op;&#125; 如上，从中我们可以看到，一个数组 free_list，很容易联想到共享机制。通过 numfree 与 free_list 的配合，实现了列表的共享，却又不同于之前谈到的整数小对象池。此处共享的是对象的指针，但真实数据的地址是不共享的，这点也很容易明白。 共享机制如上，free_list 与 small_ints 类似，都是提供对象缓冲池，但又不完全一样。 小整数对象 small_ints 是一个数组 [-5, 256] 单字节对象 characters 是一个数组 latin-1 [0 - 255] UnicodeObject interned 是一个弱引用的对象字典 ListObject free_list 是一个数组，存放着80个销毁的对象 list_dealloc12345678910111213141516171819// Objects/listobject.c/313行static void list_dealloc(PyListObject *op)&#123; Py_ssize_t i; PyObject_GC_UnTrack(op); Py_TRASHCAN_SAFE_BEGIN(op) if (op-&gt;ob_item != NULL) &#123; i = Py_SIZE(op); while (--i &gt;= 0) &#123; Py_XDECREF(op-&gt;ob_item[i]); &#125; PyMem_FREE(op-&gt;ob_item); &#125; if (numfree &lt; PyList_MAXFREELIST &amp;&amp; PyList_CheckExact(op)) free_list[numfree++] = op; else Py_TYPE(op)-&gt;tp_free((PyObject *)op); Py_TRASHCAN_SAFE_END(op)&#125; 如上，PyList_Type 中定义了 tp_dealloc 为 list_dealloc，在代码中可以看见： 对元素进行循环处理：减引用 对 ob_item 指针进行释放 尝试加入缓冲池 free_list CRUD在 PyList_New 中，很明确的指出创建对象后要先调用 PyList_SetItem PyList_SetItem1234567891011121314151617int PyList_SetItem(PyObject *list, Py_ssize_t index, PyObject *item) Set the item at index index in list to item. Return 0 on success or -1 on failure. Note: This function “steals” a reference to item and discards a reference to an item already in the list at the affected position.void PyList_SET_ITEM(PyObject *list, Py_ssize_t i, PyObject *o) Macro form of PyList_SetItem() without error checking. This is normally only used to fill in new lists where there is no previous content. Note: This macro “steals” a reference to item, and, unlike PyList_SetItem(), does not discard a reference to any item that is being replaced; any reference in list at position i will be leaked. 文档中，指出设置元素的方式，并且指明引用计数的处理原则。 1234567891011121314151617181920212223242526272829303132333435#define PyList_SET_ITEM(op, i, v) (((PyListObject *)(op))-&gt;ob_item[i] = (v))// listobject.c.218int PyList_SetItem(PyObject *op, Py_ssize_t i, PyObject *newitem)&#123; PyObject **p; // op 类型检查 if (!PyList_Check(op)) &#123; Py_XDECREF(newitem); PyErr_BadInternalCall(); return -1; &#125; // 索引值容错 if (i &lt; 0 || i &gt;= Py_SIZE(op)) &#123; Py_XDECREF(newitem); PyErr_SetString(PyExc_IndexError, "list assignment index out of range"); return -1; &#125; // 对象指针引用 p = ((PyListObject *)op) -&gt; ob_item + i; Py_XSETREF(*p, newitem); return 0;&#125;// object.h.882#define Py_XSETREF(op, op2) \ do &#123; \ PyObject *_py_tmp = (PyObject *)(op); \ (op) = (op2); \ Py_XDECREF(_py_tmp); \ &#125; while (0) 如上，对元素进行赋值操作，单纯的进行了对象指针赋值操作，时间复杂度O(1)。 需要注意的是，如上文所述，在指针替换的过程中，只减少了原地址的引用，并未增加 newitem 的引用数。 PyList_GetItem123456789101112PyObject* PyList_GetItem(PyObject *list, Py_ssize_t index) Return value: Borrowed reference. Return the object at position index in the list pointed to by list. The position must be positive, indexing from the end of the list is not supported. If index is out of bounds, return NULL and set an IndexError exception.PyObject* PyList_GET_ITEM(PyObject *list, Py_ssize_t i) Return value: Borrowed reference. Macro form of PyList_GetItem() without error checking. 文档中也指出了获取元素的方式，其中一个是宏实现。 123456789101112131415161718#define PyList_GET_ITEM(op, i) (((PyListObject *)(op))-&gt;ob_item[i])// Objects/listobject.c/198行PyObject * PyList_GetItem(PyObject *op, Py_ssize_t i)&#123; // 类型检查(略) if (i &lt; 0 || i &gt;= Py_SIZE(op)) &#123; if (indexerr == NULL) &#123; indexerr = PyUnicode_FromString( "list index out of range"); if (indexerr == NULL) return NULL; &#125; PyErr_SetObject(PyExc_IndexError, indexerr); return NULL; &#125; return ((PyListObject *)op) -&gt; ob_item[i];&#125; 如上，函数PyList_GetItem会进行容错处理。最终按索引进行数组取值，时间复杂度O(1) PyList_Insert1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// listobject.c.272int PyList_Insert(PyObject *op, Py_ssize_t where, PyObject *newitem)&#123; // 类型检查(略) return ins1((PyListObject *)op, where, newitem);&#125;// listobject.c.239static int ins1(PyListObject *self, Py_ssize_t where, PyObject *v)&#123; Py_ssize_t i, n = Py_SIZE(self); PyObject **items; // 容错处理 if (v == NULL) &#123; PyErr_BadInternalCall(); return -1; &#125; if (n == PY_SSIZE_T_MAX) &#123; PyErr_SetString(PyExc_OverflowError, "cannot add more objects to list"); return -1; &#125; // !!! 可能调整位置 !!! if (list_resize(self, n+1) &lt; 0) return -1; // 索引正负号处理 if (where &lt; 0) &#123; where += n; if (where &lt; 0) where = 0; &#125; if (where &gt; n) where = n; // 移动元素 items = self-&gt;ob_item; for (i = n; --i &gt;= where; ) items[i+1] = items[i]; // 插入值 Py_INCREF(v); items[where] = v; return 0;&#125; 如上，对数组进行插值大概可以分为几部分，从中可以看出： 索引 where 支持负值，支持大于元素个数的值 调用 list_resize 可能会调整位置 插入值，会产生移动操作。时间复杂度O(n) list_resize1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// listobject.c.25static int list_resize(PyListObject *self, Py_ssize_t newsize)&#123; PyObject **items; size_t new_allocated; Py_ssize_t allocated = self-&gt;allocated; // 如果足够大，就减小 if (allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; 1)) &#123; assert(self-&gt;ob_item != NULL || newsize == 0); Py_SIZE(self) = newsize; return 0; &#125; // 计算新的需要 new_allocated = (newsize &gt;&gt; 3) + (newsize &lt; 9 ? 3 : 6); /* check for integer overflow */ if (new_allocated &gt; SIZE_MAX - newsize) &#123; PyErr_NoMemory(); return -1; &#125; else &#123; new_allocated += newsize; &#125; if (newsize == 0) new_allocated = 0; items = self-&gt;ob_item; // 调整大小 if (new_allocated &lt;= (SIZE_MAX / sizeof(PyObject *))) PyMem_RESIZE(items, PyObject *, new_allocated); else items = NULL; if (items == NULL) &#123; PyErr_NoMemory(); return -1; &#125; // 赋值 self-&gt;ob_item = items; Py_SIZE(self) = newsize; self-&gt;allocated = new_allocated; return 0;&#125;调用链：if (list_resize(self, n+1) &lt; 0) return -1; 如上，list_resize 接收一个 list对 象指针以及新的size值，成功返回0，失败返回-1。具体分析，见下文的伪代码 12345678910111213141516def list_resize(*self, newsize): allocated = self.allocated if newsize == 0: new_allocated = 0 elif allocated /2 &lt;= newsize &lt;= allocated： self.size = newsize return 0 else: new_allocated = newsize + newsize / 8 + (3 if newsize&lt;9 else 6) PyMem_RESIZE(items, PyObject *, new_allocated); self-&gt;ob_item = items; Py_SIZE(self) = newsize; self-&gt;allocated = new_allocated; return 0; PyMem_RESIZE，调用 PyMem_REALLOC，实现最终的重新分配内存空间。 PyList_Append12345678910111213141516171819202122// Objects/listobject.c/282行static intapp1(PyListObject *self, PyObject *v)&#123; Py_ssize_t n = PyList_GET_SIZE(self); if (list_resize(self, n+1) &lt; 0) return -1; Py_INCREF(v); PyList_SET_ITEM(self, n, v); return 0;&#125;intPyList_Append(PyObject *op, PyObject *newitem)&#123; if (PyList_Check(op) &amp;&amp; (newitem != NULL)) return app1((PyListObject *)op, newitem); PyErr_BadInternalCall(); return -1;&#125; 如上，append -&gt; app1 -&gt; list_resize -&gt; PyList_SET_ITEM若 list_resize 不触发 PyMem_RESIZE()，时间复杂度为 O(1) PyList_GetSlice(list_slice)123456789101112131415161718192021222324252627282930313233343536373839404142// listobject.c.458PyObject *PyList_GetSlice(PyObject *a, Py_ssize_t ilow, Py_ssize_t ihigh)&#123; // 类型检查(略) return list_slice((PyListObject *)a, ilow, ihigh);&#125;// listobject.c.428static PyObject * list_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh)&#123; PyListObject *np; PyObject **src, **dest; Py_ssize_t i, len; // 边界处理 if (ilow &lt; 0) ilow = 0; else if (ilow &gt; Py_SIZE(a)) ilow = Py_SIZE(a); if (ihigh &lt; ilow) ihigh = ilow; else if (ihigh &gt; Py_SIZE(a)) ihigh = Py_SIZE(a); len = ihigh - ilow; // 新对象 np = (PyListObject *) PyList_New(len); if (np == NULL) return NULL; src = a-&gt;ob_item + ilow; dest = np-&gt;ob_item; // 拷贝数据指针 for (i = 0; i &lt; len; i++) &#123; PyObject *v = src[i]; Py_INCREF(v); dest[i] = v; &#125; return (PyObject *)np;&#125; 如上，对List 切片取值。其中需要注意的是，在数据拷贝过程中，拷贝的是指针，实现的是 浅拷贝。 PyList_SetSlice(list_ass_slice)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123intPyList_SetSlice(PyObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)&#123; ... // 类型检查 return list_ass_slice((PyListObject *)a, ilow, ihigh, v);&#125;// listobject.c.569static intlist_ass_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)&#123; PyObject *recycle_on_stack[8]; /* can allocate more if needed */ PyObject **recycle = recycle_on_stack; PyObject **item; PyObject **vitem = NULL; PyObject *v_as_SF = NULL; /* PySequence_Fast(v) */ Py_ssize_t n; /* # of elements in replacement list */ Py_ssize_t norig; /* # of elements in list getting replaced */ Py_ssize_t d; /* Change in size */ Py_ssize_t k; size_t s; int result = -1; /* guilty until proved innocent */#define b ((PyListObject *)v) // v = NULL，不执行操作 if (v == NULL) n = 0; else &#123; if (a == b) &#123; /* Special case "a[i:j] = a" -- copy b first */ v = list_slice(b, 0, Py_SIZE(b)); if (v == NULL) return result; result = list_ass_slice(a, ilow, ihigh, v); Py_DECREF(v); return result; &#125; v_as_SF = PySequence_Fast(v, "can only assign an iterable"); n = PySequence_Fast_GET_SIZE(v_as_SF); vitem = PySequence_Fast_ITEMS(v_as_SF); &#125; // 边界处理（略） ilow = ? ihigh = ? norig = ihigh - ilow; assert(norig&gt;= 0); d = n - norig; // a[:] = [] 清空 if (Py_SIZE(a) + d == 0) &#123; Py_XDECREF(v_as_SF); return list_clear(a); &#125; // 创建临时数据 recycle item = a-&gt;ob_item; /* recycle the items that we are about to remove */ s = norig * sizeof(PyObject *); /* If norig == 0, item might be NULL, in which case we may not memcpy from it. */ if (s) &#123; if (s &gt; sizeof(recycle_on_stack)) &#123; recycle = (PyObject **)PyMem_MALLOC(s); &#125; memcpy(recycle, &amp;item[ilow], s); &#125; // 形如 a[1:10] = [1,2] if (d &lt; 0) &#123; /* Delete -d items */ Py_ssize_t tail; tail = (Py_SIZE(a) - ihigh) * sizeof(PyObject *); // 左移 a[ihigh:]，减少空位 memmove(&amp;item[ihigh+d], &amp;item[ihigh], tail); // 拷贝后，尝试 resieze if (list_resize(a, Py_SIZE(a) + d) &lt; 0) &#123; // 失败后恢复 recycle memmove(&amp;item[ihigh], &amp;item[ihigh+d], tail); memcpy(&amp;item[ilow], recycle, s); goto Error; &#125; item = a-&gt;ob_item; &#125; // 形如 a[0:2] =[1,2,3,4] else if (d &gt; 0) &#123; /* Insert d items */ k = Py_SIZE(a); if (list_resize(a, k+d) &lt; 0) goto Error; item = a-&gt;ob_item; // 右移 a[ihigh:]，腾出位置 memmove(&amp;item[ihigh+d], &amp;item[ihigh], (k - ihigh)*sizeof(PyObject *)); &#125; // 拷贝 v 的值指针到 a for (k = 0; k &lt; n; k++, ilow++) &#123; PyObject *w = vitem[k]; Py_XINCREF(w); // 注意，从 ilow 开始 item[ilow] = w; &#125; // 释放 recycle for (k = norig - 1; k &gt;= 0; --k) Py_XDECREF(recycle[k]); result = 0; Error: if (recycle != recycle_on_stack) PyMem_FREE(recycle); Py_XDECREF(v_as_SF); return result;#undef b&#125; 当执行 a[low:high] = v 时，调用 SetSlice 方法，具体执行逻辑见注释内容。 从源码中，能分析出一些执行结果，伪代码如下：123456789101112131415161718192021222324252627282930/* a[ilow:ihigh] = v if v != NULL. del a[ilow:ihigh] if v == NULL. */&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; del a[1:1]&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]v=NULLn=0ilow = 1ihigh = 1norig = ihigh - ilow = 0d = n - norig = 0不满足 if(d) 中的任何条件，结果就是不做任何操作&gt;&gt;&gt; a[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; a[1:1] = [1]&gt;&gt;&gt; a[0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9]v!=NULLn=1ilow = 1ihigh = 1norig = ihigh - ilow = 0d = n - norig = 1满足 if(d&gt;0)，右移腾出位置，并插入a[ilow] = 1 listremove12345678910111213141516171819// listobject.c.2193static PyObject * listremove(PyListObject *self, PyObject *v)&#123; Py_ssize_t i; for (i = 0; i &lt; Py_SIZE(self); i++) &#123; int cmp = PyObject_RichCompareBool(self-&gt;ob_item[i], v, Py_EQ); if (cmp &gt; 0) &#123; if (list_ass_slice(self, i, i+1, (PyObject *)NULL) == 0) Py_RETURN_NONE; return NULL; &#125; else if (cmp &lt; 0) return NULL; &#125; PyErr_SetString(PyExc_ValueError, "list.remove(x): x not in list"); return NULL;&#125; 由上，可以看出，删除元素是通过 list_ass_slice 实现： 仅删除第一个遇见的元素，删除一个不在其中的元素，会报错 删除是通过遍历实现，时间复杂度 O(n) 总结PyListObject 也利用了缓冲池机制，只缓冲对象，不缓冲数据。 下面是粗略的时间复杂度( list_resize 不涉及到 移动时)： SetItem - O(1) GetItem - O(1) Append - O(1) Insert - O(n)，对象移动 GetSlice - O(high - low)，创建新对象，拷贝指针 SetSlice - O(n)，对象移动，拷贝指针 Remove - O(n)，遍历，对象移动]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyListObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】PyBytesObject/PyUnicodeObject]]></title>
    <url>%2F2018%2F07%2F15%2F1.2.Python%E5%AD%97%E7%AC%A6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[interface众所周知，Python2 中存在 str、bytes、unicode，Python3中只存在 str、bytes，然而却并不表示相同的含义，Python3中的 str 即Python2中的 unicode。 按照 CPython3的文档显示：Sequence Objects下辖 Bytes Objects、Unicode Objects。自PEP393之后，Unicode Type 变成了层次化的结构，用以减少内存占用。 Bytes ObjectsPyBytesObject12345// bytesobject.h.12Type PyBytesObject represents a character string. An extra zero byte isreserved at the end to ensure it is zero-terminated, but a size ispresent so strings with null bytes in them can be represented. Thisis an immutable object type. 同样开局一段注释： 字符串末尾有一个 \0 字符串计数 size 不含 \0 自身是不可变类型 12345678910111213141516// pyport.h.93/* Py_hash_t is the same size as a pointer. */typedef Py_ssize_t Py_hash_t;// bytesobject.h.31typedef struct &#123; PyObject_VAR_HEAD Py_hash_t ob_shash; char ob_sval[1]; /* Invariants: * ob_sval contains space for 'ob_size+1' elements. * ob_sval[ob_size] == 0. * ob_shash is the hash of the string or -1 if not computed yet. */&#125; PyBytesObject; 从源码可以看出： PyBytesObject 是变长对象 用 char 数组存储字符串对象，数组长度默认为 1 数组 ob_sval 含有 ob_size+1 个元素 PyBytesObject 内部有 ob_shash 变量缓存hash值，且 初始值为 -1 PyBytes_Type1234567891011121314151617// bytesobject.c.25#define PyBytesObject_SIZE (offsetof(PyBytesObject, ob_sval) + 1)// bytesobject.c.2837PyTypeObject PyBytes_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "bytes", PyBytesObject_SIZE, // tp_basicsize sizeof(char), // tp_itemsize ... (reprfunc)bytes_repr, /* tp_repr */ &amp;bytes_as_number, /* tp_as_number */ &amp;bytes_as_sequence, /* tp_as_sequence */ &amp;bytes_as_mapping, /* tp_as_mapping */ (hashfunc)bytes_hash, /* tp_hash */ ...&#125;; 恩，不出意外，也是 PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)。 Bytes 共享机制创建对象时，存在跟 small_ints 类似，使用了对象池技术的 characters：123// bytesobject.c.22static PyBytesObject *characters[UCHAR_MAX + 1];static PyBytesObject *nullstring; 当 size==1 时，将尝试从 characters 中获取对象指针。UCHAR_MAX 即 无符号整型最大值 255。 当 size==0 时，将共享使用 同一个 空字符串指针 nullstring。 123456789101112131415161718&gt;&gt;&gt; a = b'a'&gt;&gt;&gt; b = b'a'&gt;&gt;&gt; id(a),id(b)(1618457902176, 1618457902176)&gt;&gt;&gt;&gt;&gt;&gt; a = b'aa'&gt;&gt;&gt; b = b'aa'&gt;&gt;&gt; id(a),id(b)(1618457901016, 1618457902256)&gt;&gt;&gt;&gt;&gt;&gt; c = b'a'&gt;&gt;&gt; id(c)1618457902176&gt;&gt;&gt;&gt;&gt;&gt; d = b''&gt;&gt;&gt; e = b''&gt;&gt;&gt; id(d),id(e)(1618427315824, 1618427315824) PyBytes_FromString12345PyObject* PyBytes_FromString(const char *v)PyObject* PyBytes_FromStringAndSize(const char *v, Py_ssize_t len)PyObject* PyBytes_FromFormat(const char *format, ...)PyObject* PyBytes_FromFormatV(const char *format, va_list vargs)PyObject* PyBytes_FromObject(PyObject *o) 同样，CPython定义了很多创建 BytesObejct 的方法，下面也只看其中一种。 123456789101112131415161718192021222324252627282930313233343536// bytesobject.c.132/* For PyBytes_FromString(), the parameter `str' points to a null-terminated string containing exactly `size' bytes.*/PyObject * PyBytes_FromString(const char *str)&#123; size_t size; PyBytesObject *op; assert(str != NULL); size = strlen(str); if (size == 0 &amp;&amp; (op = nullstring) != NULL) &#123; Py_INCREF(op); return (PyObject *)op; &#125; if (size == 1 &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != NULL) &#123; Py_INCREF(op); return (PyObject *)op; &#125; /* Inline PyObject_NewVar */ op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size); (void)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size); // PY_TYPE(op) = PyBytes_Type op-&gt;ob_shash = -1; memcpy(op-&gt;ob_sval, str, size+1); /* share short strings */ if (size == 0) &#123; nullstring = op; Py_INCREF(op); &#125; else if (size == 1) &#123; characters[*str &amp; UCHAR_MAX] = op; Py_INCREF(op); &#125; return (PyObject *) op;&#125; 从上面的源码可以看出，PyBytes_FromString 大概分为4部分： 计算 字符串长度 strlen(str) 处理 空字符串 size == 0，尝试获取全局变量 nullstring 处理 单字符串 size == 1，尝试获取共享对象 characters 申请空间、创建对象、拷贝内存、返回结果 需要注意的是： PyObject_MALLOC 申请空间大小为 PyBytesObject_SIZE + size，是一个确定的不能再次改变的值 memcpy(op-&gt;ob_sval, str, size+1)， size+1 表明把 字符数组的 ‘\0’也存入了 op_ob_sval，与前文 相对应 op-&gt;ob_shash = -1，hash 缓冲值，赋值-1，与前文相对应 共享数组 characters ，是在对象的不断创建中，逐渐填满 Unicode ObjectsPyUnicodeObject1234567891011121314151617181920212223242526272829/* There are 4 forms of Unicode strings: - compact ascii: * structure = PyASCIIObject * kind = PyUnicode_1BYTE_KIND * 仅 ASCII 字符，7bit * throw PyUnicode_New - compact: * structure = PyCompactUnicodeObject * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * 仅 latin1 且 Non-ASCII 字符，&gt;=8bit * throw PyUnicode_New - legacy string, not ready: * structure = PyUnicodeObject * kind = PyUnicode_WCHAR_KIND * PyUnicode_FromUnicode(NULL, len); - legacy string, ready: * structure = PyUnicodeObject structure * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * PyUnicode_FromUnicode(NULL, len); // compact 与 legacy 的显著区别： Compact strings use only one memory block (structure + characters), whereas legacy strings use one block for the structure and one block for characters.*/ 同样开篇一段注释，详细内容可以看PEP393，之所以弄得这么复杂，就是为了权衡通用性与空间利用率。下面还是来看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// unicodeobject.h.197/* ASCII-only strings created through PyUnicode_New; utf8_length == wstr_length == length; the utf8 pointer == data pointer == wstr */typedef struct &#123; PyObject_HEAD Py_ssize_t length; /* 码位(code points) */ Py_hash_t hash; /* Hash value; -1 if not set */ struct &#123; unsigned int interned:2; // 共享机制 unsigned int kind:3; unsigned int compact:1; unsigned int ascii:1; unsigned int ready:1;/ unsigned int :24; &#125; state; wchar_t *wstr; /* 真实字符串 (null-terminated) */&#125; PyASCIIObject;/* Non-ASCII strings allocated through PyUnicode_New; the data immediately follow the structure. */typedef struct &#123; PyASCIIObject _base; Py_ssize_t utf8_length; /* Number of bytes in utf8, excluding the terminating \0. */ char *utf8; /* UTF-8 representation (null-terminated) */ Py_ssize_t wstr_length; /* Number of code points in wstr, possible * surrogates count as two code points. */&#125; PyCompactUnicodeObject;/* Strings allocated through PyUnicode_FromUnicode(NULL, len); The actual string data is initially in the wstr block; and copied into the data block using _PyUnicode_Ready. */typedef struct &#123; PyCompactUnicodeObject _base; union &#123; void *any; Py_UCS1 *latin1; Py_UCS2 *ucs2; Py_UCS4 *ucs4; &#125; data; /* Canonical, smallest-form Unicode buffer */&#125; PyUnicodeObject; 如上，定义了3种Objec结构体，具体功能及创建方式，见注释内容。 PyUnicode_Type123456789101112131415161718// unicodeobject.c.15170PyTypeObject PyUnicode_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "str", /* tp_name */ sizeof(PyUnicodeObject), /* tp_size */ 0, /* tp_itemsize */ /* Slots */ (destructor)unicode_dealloc, /* tp_dealloc */ ... unicode_repr, /* tp_repr */ &amp;unicode_as_number, /* tp_as_number */ &amp;unicode_as_sequence, /* tp_as_sequence */ &amp;unicode_as_mapping, /* tp_as_mapping */ (hashfunc) unicode_hash, /* tp_hash*/ ... unicode_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; 可见，PyUnicode_Type 就是 Python3 中的 str。 创建对象与 PyBytesObject 类似，PyUnicodeObject 也存在好几种创建方式，详见python.org。由于存在多种 Unicode OBject，各自的创建方式还不一样，下面分开查看。 PyUnicode_New12345678910111213141516171819202122232425262728293031// unicodeobject.c.1220PyObject * PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)&#123; PyObject *obj; PyCompactUnicodeObject *unicode; void *data; enum PyUnicode_Kind kind; int is_sharing, is_ascii; Py_ssize_t char_size; Py_ssize_t struct_size; ... /* 判断 获取变量的值 */ obj = (PyObject *) PyObject_MALLOC(struct_size + (size + 1) * char_size); obj = PyObject_INIT(obj, &amp;PyUnicode_Type); unicode = (PyCompactUnicodeObject *)obj; _PyUnicode_LENGTH(unicode) = size; _PyUnicode_HASH(unicode) = -1; _PyUnicode_STATE(unicode).interned = 0; _PyUnicode_STATE(unicode).kind = kind; _PyUnicode_STATE(unicode).compact = 1; _PyUnicode_STATE(unicode).ready = 1; _PyUnicode_STATE(unicode).ascii = is_ascii; ... /* 根据变量值, 赋值 unicode-&gt;utf8 = ? unicode-&gt;utf8_length = ? _PyUnicode_WSTR_LENGTH(unicode) = ? _PyUnicode_WSTR(unicode) = ? */ return obj;&#125; PyUnicode_New 是创建compact string的方式，代码很长，多数都是在容错处理。最终 MALLOC，然后赋初值，return。那么，问题来了，难道 Unicode Object 没有共享机制？ PyUnicode_FromUnicode12345678910111213141516171819202122232425// unicodeobject.c.1993PyObject * PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)&#123; PyObject *unicode; Py_UCS4 maxchar = 0; Py_ssize_t num_surrogates; if (u == NULL) return (PyObject*)_PyUnicode_New(size); /* 宏套宏，最终实现共享 unicode_empty=PyUnicode_New(0, 0); */ if (size == 0) _Py_RETURN_UNICODE_EMPTY(); /* 共享 Single character*/ if (size == 1 &amp;&amp; (Py_UCS4)*u &lt; 256) return get_latin1_char((unsigned char)*u); /* 创建新 not single 对象 */ unicode = PyUnicode_New(size - num_surrogates, maxchar); switch (PyUnicode_KIND(unicode)) &#123; /* case 不同 kind 执行执行相应的转换*/ &#125; return unicode_result(unicode);&#125; 如上，原始代码很长，上面只截取了相对重要的部分。好高兴，终于看到 Unicode 共享机制的苗头了，不过还得一个一个来看。 _PyUnicode_New12345678910111213141516171819202122232425262728293031323334353637383940414243// unicodeobject.c.1067static PyUnicodeObject * _PyUnicode_New(Py_ssize_t length)&#123; PyUnicodeObject *unicode; size_t new_size; /* 共享 empty strings */ if (length == 0 &amp;&amp; unicode_empty != NULL) &#123; Py_INCREF(unicode_empty); return (PyUnicodeObject*)unicode_empty; &#125; /* 容错代码(略)：length 不能过大，也不能 &lt; 0 */ // 创建对象 unicode = PyObject_New(PyUnicodeObject, &amp;PyUnicode_Type); new_size = sizeof(Py_UNICODE) * ((size_t)length + 1); // 赋初值 _PyUnicode_WSTR_LENGTH(unicode) = length; _PyUnicode_HASH(unicode) = -1; _PyUnicode_STATE(unicode).interned = 0; _PyUnicode_STATE(unicode).kind = 0; _PyUnicode_STATE(unicode).compact = 0; _PyUnicode_STATE(unicode).ready = 0; _PyUnicode_STATE(unicode).ascii = 0; _PyUnicode_DATA_ANY(unicode) = NULL; _PyUnicode_LENGTH(unicode) = 0; _PyUnicode_UTF8(unicode) = NULL; _PyUnicode_UTF8_LENGTH(unicode) = 0; // 真实数据 _PyUnicode_WSTR(unicode) = (Py_UNICODE*) PyObject_MALLOC(new_size); // 讨巧，只处理数组两端 _PyUnicode_WSTR(unicode)[0] = 0; _PyUnicode_WSTR(unicode)[length] = 0; return unicode;&#125;// 调用链：if (u == NULL) return (PyObject*)_PyUnicode_New(size); 源码依然很长，从整理后的代码可以看出，_PyUnicode_New 使用场景是：知道字符串长度，但不知道字符串的具体内容。只创建了内存空间，真实数据 ‘都是0’ 。 get_latin1_char(latin-1共享机制)123456789101112131415161718static PyObject* get_latin1_char(unsigned char ch)&#123; PyObject *unicode = unicode_latin1[ch]; if (!unicode) &#123; unicode = PyUnicode_New(1, ch); if (!unicode) return NULL; PyUnicode_1BYTE_DATA(unicode)[0] = ch; assert(_PyUnicode_CheckConsistency(unicode, 1)); unicode_latin1[ch] = unicode; &#125; Py_INCREF(unicode); return unicode;&#125;// 调用链：if (size == 1 &amp;&amp; (Py_UCS4)*u &lt; 256) return get_latin1_char((unsigned char)*u); 在上面的代码中，看到了熟悉的套路，一个数组unicode_latin1。1234// unicodeobject.c.213/* Single character Unicode strings in the Latin-1 range are being shared as well. */static PyObject *unicode_latin1[256] = &#123;NULL&#125;; 可见unicode_latin1数组，是一开始就创建，但并未填充数据，这就是单 unicode 的共享机制。 unicode_result123456789101112131415161718192021222324252627282930313233343536// unicodeobject.c.548static PyObject* unicode_result(PyObject *unicode)&#123; if (PyUnicode_IS_READY(unicode)) return unicode_result_ready(unicode); else return unicode_result_wchar(unicode);&#125;static PyObject* unicode_result_ready(PyObject *unicode)&#123; Py_ssize_t length; length = PyUnicode_GET_LENGTH(unicode); if (length == 0) &#123; // 共享 unicode_empty return unicode_empty; &#125; if (length == 1) &#123; void *data = PyUnicode_DATA(unicode); int kind = PyUnicode_KIND(unicode); Py_UCS4 ch = PyUnicode_READ(kind, data, 0); if (ch &lt; 256) &#123; // 共享 latin1_char return unicode; &#125; &#125; return unicode;&#125;// 调用链：/* 创建新 not single 对象 PyUnicode_New 中赋值 unicode.ready = 1; */unicode = PyUnicode_New(size - num_surrogates, maxchar);return unicode_result(unicode); 从上面的代码来看，似乎 unicode_result 对 PyUnicode_New 来说，纯粹是多余的。 从整个PyUnicode_FromUnicode来看，只是针对单latin-1字符，进行了共享。那就不能解释下面的代码：123456789101112&gt;&gt;&gt; a = 'abcde'&gt;&gt;&gt; b = 'abcde'&gt;&gt;&gt; id(a), id(b),id(a)==id(b)(1605538588408, 1605538588408, True)&gt;&gt;&gt; del a&gt;&gt;&gt; del b&gt;&gt;&gt; a = 'abcde'&gt;&gt;&gt; id(a)1605538115744&gt;&gt;&gt; b = 'abcde'&gt;&gt;&gt; id(a) == id(b)True Unicode 共享机制1234// unicodeobject.h.412#define SSTATE_NOT_INTERNED 0 // 未共享#define SSTATE_INTERNED_MORTAL 1 // 共享，不增加引用计数#define SSTATE_INTERNED_IMMORTAL 2 // 永久，不会被销毁 在上文的PyUnicode_New、_PyUnicode_New中，都进行了 unicode.interned = 0 赋值操作。在源码中发现 0 对应着不共享。 同时在 unicodeobject.c源码中，发现 4个可疑函数：1234void PyUnicode_InternInPlace(PyObject **p)void PyUnicode_InternImmortal(PyObject **p)PyObject * PyUnicode_InternFromString(const char *cp)void _Py_ReleaseInternedUnicodeStrings(void) 在 CPython 的其他源码中，大量存在类似true_str = PyUnicode_InternFromString(&quot;True&quot;)的代码，而PyUnicode_InternFromString内部又调用PyUnicode_InternInPlace。 PyUnicode_InternInPlace123456789101112131415161718192021222324252627282930313233343536373839// unicodeobject.c.174/* 注意，interned 不会影响 deallocation*/static PyObject *interned = NULL;static PyObject *unicode_empty = NULL;// unicodeobject.c.15278void PyUnicode_InternInPlace(PyObject **p)&#123; PyObject *s = *p; PyObject *t; // 类型检查，对子类 不共享 if (s == NULL || !PyUnicode_Check(s)) return; /* If it's a subclass, we don't really know what putting it in the interned dict might do. */ if (!PyUnicode_CheckExact(s)) return; if (PyUnicode_CHECK_INTERNED(s)) return; // 初始化 interned 字典 if (interned == NULL) &#123; interned = PyDict_New(); &#125; Py_ALLOW_RECURSION // ceval.h.113，保存线程 recursion_critical t = PyDict_SetDefault(interned, s, s); Py_END_ALLOW_RECURSION // 恢复 recursion_critical // 之前不存在 if (t != s) &#123; Py_INCREF(t); Py_SETREF(*p, t); return; &#125; // 已经存在 Py_REFCNT(s) -= 2; // k,v 各一次 _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL; // == 1&#125; 可以发现： 共享前会进行类型检查，共享历史检查 共享是用 interned 这个字典对象实现 PyDict_SetDefault 返回的是字典中对象的指针 若 t != s 即，字典中已经存在该值，对t 减引用，修改 *p 指向，返回 若 t ==s 即，字典中之前不存在，那么 放入字典，并设置 s.interned = 1 interned 字典中的指针，不作为对象的有效引用，因此执行 Py_REFCNT(s) -= 2 问题暂时解决了，利用 interned 字典+PyUnicode_Intern*实现了共享。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyBytesObject</tag>
        <tag>PyUnicodeObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】PyLongObject]]></title>
    <url>%2F2018%2F07%2F14%2F1.1.Python%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中所指 “前文”，皆指本人博客中【Python源码分析】中的系列文章 参考 《Python源码剖析》，感谢陈儒先生的著作 Python.org-Integer Objects，感谢Python社区的成果共享 PyLongObject在 Python2 中，存在 PyIntObject 和 PyLongObject 两种类型。前者是一个定长对象，后者是一个变长对象。Python3中 只存在后者。在 Python2 的结构体中 定义的是 long ob_ival，而 Python3 中定义的是只有1个元素的数组。1234567891011121314// longobject.h.10typedef struct _longobject PyLongObject;// longintrepr.h.85struct _longobject &#123; PyObject_VAR_HEAD digit ob_digit[1]; // digit 与平台相关，长度不一致&#125;;/* ob_size == 0 -&gt; zero ob_size &lt; 0 -&gt; 负数 PyLong_SHIFT == 30 or 15 value == SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)*/ 由上可以看出，在 Python 中，整形的存储方式，是存储在一个数组中。因此通过控制 PyVarObject 的 ob_size 值，可以表示出非常非常大的数。 PyTypeObject12345678910111213// longobject.c.5431PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "int", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ... &amp;long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ long_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; 可见： int对象的类型对象是 PyLong_Type 从之前的 PyObject 分析也能得出 PyLong_Type的类型对象是 PyType_Type int对象，只支持 as_number，不支持作为序列、映射对象操作 123456789101112131415161718// longobject.c.5393static PyNumberMethods long_as_number = &#123; (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ ... long_float, /*nb_float*/ ...&#125;;// longobject.c.3108static PyObject *long_add(PyLongObject *a, PyLongObject *b)&#123; PyLongObject *z; .. // 检查，计算，返回 return (PyObject *)z;&#125; long_as_number 是前文所述 PyNumberMethods 函数簇的 一个结构体实例，初始化了大量方法。如上面的 long_add 操作，创建并返回一个新的 PyObject。 对象池 small_ints1234567891011121314151617181920// longobject.c.12#define NSMALLPOSINTS 257#define NSMALLNEGINTS 5static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];// longobject.c.5514int _PyLong_Init(void)&#123; int ival, size; PyLongObject *v = small_ints; for (ival = -NSMALLNEGINTS; ival &lt; NSMALLPOSINTS; ival++, v++) &#123; size = (ival &lt; 0) ? -1 : ((ival == 0) ? 0 : 1); (void)PyObject_INIT(v, &amp;PyLong_Type); // Py_TYPE(op) = tp; Py_SIZE(v) = size; v-&gt;ob_digit[0] = (digit)abs(ival); &#125; return 1;&#125; 如上，当 Python 初始化时，_PyLong_Init 被调用，然后会 初始化 small_ints数组，作为小整数对象池来共享使用。 前面也提到了 _longobject 结构体中 定义的是 digit ob_digit[1]，从源码中可以发现： small_ints数组长度，默认[-5, 256] size 与 值的关系：小于0 or 等于0 or 大于0 小整数共享123456789101112131415// longobject.c.51#define CHECK_SMALL_INT(ival) \ do if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123; \ return get_small_int((sdigit)ival); \ &#125; while(0)// longobject.c.37static PyObject * get_small_int(sdigit ival)&#123; PyObject *v; assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS); v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS]; Py_INCREF(v); return v;&#125; 如上，通过宏 CHECK_SMALL_INT，可以共享小整数。返回增加引用计数，并且返回指针。 创建对象1234567891011PyObject* PyLong_FromLong(long v)PyObject* PyLong_FromUnsignedLong(unsigned long v)PyObject* PyLong_FromSsize_t(Py_ssize_t v)PyObject* PyLong_FromSize_t(size_t v)PyObject* PyLong_FromLongLong(long long v)PyObject* PyLong_FromUnsignedLongLong(unsigned long long v)PyObject* PyLong_FromDouble(double v)PyObject* PyLong_FromString(const char *str, char **pend, int base)PyObject* PyLong_FromUnicode(Py_UNICODE *u, Py_ssize_t length, int base)PyObject* PyLong_FromUnicodeObject(PyObject *u, int base)PyObject* PyLong_FromVoidPtr(void *p) 在 CPython3.6.6 中，提供了大量创建 PyLongObject 的方法。下面，我们将查看其中一个。 PyLong_FromLong123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051PyObject * PyLong_FromLong(long ival)&#123; PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so &gt;&gt; doesn't propagate sign bit */ int ndigits = 0; int sign; CHECK_SMALL_INT(ival); // 宏，尝试小整数共享 // 处理得到 abs_ival(unsigned long) if (ival &lt; 0) &#123; /* negate: can't write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; &#125; else &#123; abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; &#125; /* 处理 single-digit ints */ if (!(abs_ival &gt;&gt; PyLong_SHIFT)) &#123; v = _PyLong_New(1); if (v) &#123; Py_SIZE(v) = sign; v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST(abs_ival, unsigned long, digit); // pyport.h.304: #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE) &#125; return (PyObject*)v; &#125; /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) &#123; ++ndigits; t &gt;&gt;= PyLong_SHIFT; &#125; v = _PyLong_New(ndigits); if (v != NULL) &#123; digit *p = v-&gt;ob_digit; Py_SIZE(v) = ndigits*sign; t = abs_ival; while (t) &#123; *p++ = Py_SAFE_DOWNCAST(t &amp; PyLong_MASK, unsigned long, digit); t &gt;&gt;= PyLong_SHIFT; &#125; &#125; return (PyObject *)v;&#125; 如上，创建一个 int 对象，主要有以下几个步骤： 尝试从对象池中获取 处理获取 abs_value 处理 single-digit 循环处理 Larger numbers 代码很简单，下面只看一下 _PyLong_New 具体逻辑。 _PyLong_New12345678910111213141516// longobject.c.179#define MAX_LONG_DIGITS \ ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit))PyLongObject * _PyLong_New(Py_ssize_t size)&#123; PyLongObject *result; if (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) &#123; PyErr_SetString(PyExc_OverflowError, "too many digits in integer"); return NULL; &#125; result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size*sizeof(digit)); return (PyLongObject*)PyObject_INIT_VAR(result, &amp;PyLong_Type, size);&#125; 从代码可以看出，能够表示的最大整数是跟堆内存相关的，几乎可以表示无穷大的数了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
        <tag>PyLongObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CPython3.6源码分析】PyObject/PyObjectType]]></title>
    <url>%2F2018%2F07%2F14%2F1.0.PyObject%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中主要参考陈儒先生的著作，在正文中将不再重复声明 参考资料 《Python源码剖析》，感谢陈儒先生的著作 python.org，感谢Python社区的成果共享 Interface 123456789101112131415161718192021222324252627# object.h.8/* Object and type object interface */Objects are structures allocated on the heap.Objects are never allocated statically or on the stack;An object has a &apos;reference count&apos; that is increased or decreased when apointer to the object is copied or deleted;when the reference count reaches zero there are no references to the object leftand it can be removed from the heap.An object has a &apos;type&apos; that determines what it represents and what kindof data it contains. An object&apos;s type is fixed when it is created.Types themselves are represented as objects; an object contains apointer to the corresponding type object. The type itself has a typepointer pointing to the object representing the type &apos;type&apos;, whichcontains a pointer to itself!).once allocated an object keeps the same size and address.Objects that must hold variable-size data can contain pointers tovariable-size parts of the object.Objects are always accessed through pointers of the type &apos;PyObject *&apos;.The type &apos;PyObject&apos; is a structure that only contains the reference countand the type pointer.A standard interface exists for objects that contain an array of itemswhose size is determined when the object is allocated. 开篇一段注释，从注释中能提取到很多要点： 对象堆分配、从不栈分配 垃圾回收之引用计数 对象、类型对象、type 容器对象可变依据：持有指针 基石对象 PyObject 与类型转换 PyObject123456789101112// object.h.98typedef struct _object &#123; // ifdef Py_TRACE_REFS，定义双向链表存储所有堆上存活对象指针 _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; # 引用计数 struct _typeobject *ob_type; # 类型对象指针&#125; PyObject;typedef struct &#123; PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part，作 int 理解*/&#125; PyVarObject; 在 Python 中，实际上没有任何东西被声明为 PyObject，但所有对象都可以通过 PyObject 进行引用。类似的还有，指向容器的 PyVarObject 。 PyObject 结构体中包含： 指向类型对象 _typeobject 的指针 ob_type 用于垃圾回收的引用计数 ob_refcnt 对于容器对象，PyObject_VAR_HEAD 用 ob_size 代表元素个数。 PyTypeObject1234567891011121314151617181920212223242526272829// include.h.346typedef struct _typeobject &#123; PyObject_VAR_HEAD // #define PyObject_VAR_HEAD PyVarObject ob_base; const char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; /* Method suites for standard classes */ PyNumberMethods *tp_as_number; PySequenceMethods *tp_as_sequence; PyMappingMethods *tp_as_mapping; /* More standard operations (here for binary compatibility) */ /* Functions to access object as input/output buffer */ /* Flags to define presence of optional/expanded features */ /* Documentation string */ /* call function for all accessible objects */ /* delete references to contained objects */ /* weak reference enabler */ /* Iterators */ getiterfunc tp_iter; iternextfunc tp_iternext; /* Attribute descriptor and subclassing stuff */ struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members;&#125; PyTypeObject; 创建对象之前，必须知道申请的内存空间大小，而这些元信息就存储在对象的类型对象中。含有头域PyObject_VAR_HEAD，表明类型对象本身是 可变长对象。结构体内存储大量信息，主要包括： 常规信息：类型名、Doc、tp_itemsize、tp_basicsize等 常规方法指针：tp_new、tp_init、tp_free等 函数簇：PyNumberMethods、PySequenceMethods等 123456// object.h.301typedef struct &#123; lenfunc mp_length; binaryfunc mp_subscript; objobjargproc mp_ass_subscript;&#125; PyMappingMethods; 在函数簇 PyMappingMethods 中，定义了支持映射的对象应该支持的操作。反过来说，一旦定义了 其中的方法，那么该对象就支持该方法。正因为 PyTypeObject 中同时定义了三种函数簇，所以才可以实现鸭子类型。 PyType_Type前面说过，PyVarObject -&gt; PyObject -&gt; PyTypeObject，但 PyTypeObject 内部又存在 PyVarObject。那么，这个内部的 VarObject 的 type 又是什么？此处先来看下 a = int(10) == 整型对象 a.ob_type == PyLong_Type PyLong_Type.ob_type == PyType_Type PyType_Type.ob_type == PyType_Type 123456789101112131415161718192021// object.h.85#define PyObject_HEAD_INIT(type) &#123; 1, type &#125;,#define PyVarObject_HEAD_INIT(type, size) &#123; PyObject_HEAD_INIT(type) size &#125;,// typeobject.c.3383PyTypeObject PyType_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) /* ob_base = &#123;ob_refcnt=1, *ob_type=PyType_Type&#125; ob_size = 0 */ "type", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ ... type_doc, /* tp_doc */ ... type_init, /* tp_init */ type_new, /* tp_new */ ...&#125;; 如上，可以看见 tp_name == ‘type’，即 Python 中 type 的类型对象就是 PyType_Type。第一句，&amp;PyType_Type 印证了 type(type)==type，形成自旋。 对于内建对象，Python 中有定义好的结构体，如 PyLongObject-&gt;PyLong_Type。而对于用户创建的类，就必须动态创建 type 对象。我们知道，创建类可以通过 type() 的方式生成，最终将调用 PyType_Type.type_new()。 PyBaseObject_Type1234567891011// typeobject.c.4535PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "object", /* tp_name */ sizeof(PyObject), /* tp_basicsize */ object_methods, /* tp_methods */ object_init, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ object_new, /* tp_new */&#125;; 从上可以看出，object的类型对象就是PyBaseObject_Type。第一句，&amp;PyType_Type 印证了 type(object)==type，即 object 的类型对象，的类型对象是 PyType_Type。 object VS type这里要搞清楚的是： 对象，是通过 PyObject 结构体定义的，必须包含 ob_refcnt、ob_type 类型，PyBaseObject_Type、PyType_Type，本身也是可变对象 PyVarObject 普通对象的类型指针，ob_type，指向的是 类型对象：PyBaseObject_Type、PyType_Type 而 PyBaseObject_Type 本身也是对象，也具有 ob_type，指向的是 PyType_Type 最终 PyType_Type 也是对象，其 ob_type，指向的是 自身 123456789101112PyTypeObject PyList_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;list&quot;,&#125;PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;int&quot;,&#125;PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;object&quot;,&#125; 层次结构： 基石，PyObject，一切皆对象 最顶端的是 type，这也正是 type 被称为 metaclass 的原因。 内置对象 list/int/object等，其类型对象都是指向 type。 实例对象 int(1)，其类型对象是 PyLong_Type。 假设： 没有 1，好像可以照常用，只是不能创建 类了 没有 2, 也可以照常用，只是每次需要自己创建 int等基础类型 没有 3，不能实例化了，啥也干不了 容易混淆的是： object，既可以说是实例对象 3，又可以说是 类型对象 2，还可以说成 python对象 0 type，既可以说成实例对象3的类型对象 2，又可以说成元类 1 如果有人问，type 和 object 的关系，就得先问清楚他说的 type和object 指哪一个层面！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>CPython3.6源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开通啦]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在时间、成本、道德约束等各种抉择下，最终还是选择了github.io。嗯，安心写博客。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>起风了</tag>
      </tags>
  </entry>
</search>
