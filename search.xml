<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Python源码剖析】PyBytesObject/PyUnicodeObject]]></title>
    <url>%2F2018%2F07%2F15%2FPython%E5%AD%97%E7%AC%A6%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[interface众所周知，Python2 中存在 str、bytes、unicode，Python3中只存在 str、bytes，然而却并不表示相同的含义，Python3中的 str 即Python2中的 unicode。 按照 CPython3的文档显示：Sequence Objects下辖 Bytes Objects、Unicode Objects。自PEP393之后，Unicode Type 变成了层次化的结构，用以减少内存占用。 Bytes ObjectsPyBytesObject12345// bytesobject.h.12Type PyBytesObject represents a character string. An extra zero byte isreserved at the end to ensure it is zero-terminated, but a size ispresent so strings with null bytes in them can be represented. Thisis an immutable object type. 同样开局一段注释： 字符串末尾有一个 \0 字符串计数 size 不含 \0 自身是不可变类型 12345678910111213141516// pyport.h.93/* Py_hash_t is the same size as a pointer. */typedef Py_ssize_t Py_hash_t;// bytesobject.h.31typedef struct &#123; PyObject_VAR_HEAD Py_hash_t ob_shash; char ob_sval[1]; /* Invariants: * ob_sval contains space for 'ob_size+1' elements. * ob_sval[ob_size] == 0. * ob_shash is the hash of the string or -1 if not computed yet. */&#125; PyBytesObject; 从源码可以看出： PyBytesObject 是变长对象 用 char 数组存储字符串对象，数组长度默认为 1 数组 ob_sval 含有 ob_size+1 个元素 PyBytesObject 内部有 ob_shash 变量缓存hash值，且 初始值为 -1 PyBytes_Type1234567891011121314151617// bytesobject.c.25#define PyBytesObject_SIZE (offsetof(PyBytesObject, ob_sval) + 1)// bytesobject.c.2837PyTypeObject PyBytes_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "bytes", PyBytesObject_SIZE, // tp_basicsize sizeof(char), // tp_itemsize ... (reprfunc)bytes_repr, /* tp_repr */ &amp;bytes_as_number, /* tp_as_number */ &amp;bytes_as_sequence, /* tp_as_sequence */ &amp;bytes_as_mapping, /* tp_as_mapping */ (hashfunc)bytes_hash, /* tp_hash */ ...&#125;; 恩，不出意外，也是 PyVarObject_HEAD_INIT(&amp;PyType_Type, 0)。 Bytes 共享机制创建对象时，存在跟 small_ints 类似，使用了对象池技术的 characters：123// bytesobject.c.22static PyBytesObject *characters[UCHAR_MAX + 1];static PyBytesObject *nullstring; 当 size==1 时，将尝试从 characters 中获取对象指针。UCHAR_MAX 即 无符号整型最大值 255。 当 size==0 时，将共享使用 同一个 空字符串指针 nullstring。 123456789101112131415161718&gt;&gt;&gt; a = b'a'&gt;&gt;&gt; b = b'a'&gt;&gt;&gt; id(a),id(b)(1618457902176, 1618457902176)&gt;&gt;&gt;&gt;&gt;&gt; a = b'aa'&gt;&gt;&gt; b = b'aa'&gt;&gt;&gt; id(a),id(b)(1618457901016, 1618457902256)&gt;&gt;&gt;&gt;&gt;&gt; c = b'a'&gt;&gt;&gt; id(c)1618457902176&gt;&gt;&gt;&gt;&gt;&gt; d = b''&gt;&gt;&gt; e = b''&gt;&gt;&gt; id(d),id(e)(1618427315824, 1618427315824) PyBytes_FromString12345PyObject* PyBytes_FromString(const char *v)PyObject* PyBytes_FromStringAndSize(const char *v, Py_ssize_t len)PyObject* PyBytes_FromFormat(const char *format, ...)PyObject* PyBytes_FromFormatV(const char *format, va_list vargs)PyObject* PyBytes_FromObject(PyObject *o) 同样，CPython定义了很多创建 BytesObejct 的方法，下面也只看其中一种。 123456789101112131415161718192021222324252627282930313233343536// bytesobject.c.132/* For PyBytes_FromString(), the parameter `str' points to a null-terminated string containing exactly `size' bytes.*/PyObject * PyBytes_FromString(const char *str)&#123; size_t size; PyBytesObject *op; assert(str != NULL); size = strlen(str); if (size == 0 &amp;&amp; (op = nullstring) != NULL) &#123; Py_INCREF(op); return (PyObject *)op; &#125; if (size == 1 &amp;&amp; (op = characters[*str &amp; UCHAR_MAX]) != NULL) &#123; Py_INCREF(op); return (PyObject *)op; &#125; /* Inline PyObject_NewVar */ op = (PyBytesObject *)PyObject_MALLOC(PyBytesObject_SIZE + size); (void)PyObject_INIT_VAR(op, &amp;PyBytes_Type, size); // PY_TYPE(op) = PyBytes_Type op-&gt;ob_shash = -1; memcpy(op-&gt;ob_sval, str, size+1); /* share short strings */ if (size == 0) &#123; nullstring = op; Py_INCREF(op); &#125; else if (size == 1) &#123; characters[*str &amp; UCHAR_MAX] = op; Py_INCREF(op); &#125; return (PyObject *) op;&#125; 从上面的源码可以看出，PyBytes_FromString 大概分为4部分： 计算 字符串长度 strlen(str) 处理 空字符串 size == 0，尝试获取全局变量 nullstring 处理 单字符串 size == 1，尝试获取共享对象 characters 申请空间、创建对象、拷贝内存、返回结果 需要注意的是： PyObject_MALLOC 申请空间大小为 PyBytesObject_SIZE + size，是一个确定的不能再次改变的值 memcpy(op-&gt;ob_sval, str, size+1)， size+1 表明把 字符数组的 ‘\0’也存入了 op_ob_sval，与前文 相对应 op-&gt;ob_shash = -1，hash 缓冲值，赋值-1，与前文相对应 共享数组 characters ，是在对象的不断创建中，逐渐填满 Unicode ObjectsPyUnicodeObject1234567891011121314151617181920212223242526272829/* There are 4 forms of Unicode strings: - compact ascii: * structure = PyASCIIObject * kind = PyUnicode_1BYTE_KIND * 仅 ASCII 字符，7bit * throw PyUnicode_New - compact: * structure = PyCompactUnicodeObject * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * 仅 latin1 且 Non-ASCII 字符，&gt;=8bit * throw PyUnicode_New - legacy string, not ready: * structure = PyUnicodeObject * kind = PyUnicode_WCHAR_KIND * PyUnicode_FromUnicode(NULL, len); - legacy string, ready: * structure = PyUnicodeObject structure * kind = PyUnicode_1BYTE_KIND, PyUnicode_2BYTE_KIND or PyUnicode_4BYTE_KIND * PyUnicode_FromUnicode(NULL, len); // compact 与 legacy 的显著区别： Compact strings use only one memory block (structure + characters), whereas legacy strings use one block for the structure and one block for characters.*/ 同样开篇一段注释，详细内容可以看PEP393，之所以弄得这么复杂，就是为了权衡通用性与空间利用率。下面还是来看代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// unicodeobject.h.197/* ASCII-only strings created through PyUnicode_New; utf8_length == wstr_length == length; the utf8 pointer == data pointer == wstr */typedef struct &#123; PyObject_HEAD Py_ssize_t length; /* 码位(code points) */ Py_hash_t hash; /* Hash value; -1 if not set */ struct &#123; unsigned int interned:2; // 共享机制 unsigned int kind:3; unsigned int compact:1; unsigned int ascii:1; unsigned int ready:1;/ unsigned int :24; &#125; state; wchar_t *wstr; /* 真实字符串 (null-terminated) */&#125; PyASCIIObject;/* Non-ASCII strings allocated through PyUnicode_New; the data immediately follow the structure. */typedef struct &#123; PyASCIIObject _base; Py_ssize_t utf8_length; /* Number of bytes in utf8, excluding the terminating \0. */ char *utf8; /* UTF-8 representation (null-terminated) */ Py_ssize_t wstr_length; /* Number of code points in wstr, possible * surrogates count as two code points. */&#125; PyCompactUnicodeObject;/* Strings allocated through PyUnicode_FromUnicode(NULL, len); The actual string data is initially in the wstr block; and copied into the data block using _PyUnicode_Ready. */typedef struct &#123; PyCompactUnicodeObject _base; union &#123; void *any; Py_UCS1 *latin1; Py_UCS2 *ucs2; Py_UCS4 *ucs4; &#125; data; /* Canonical, smallest-form Unicode buffer */&#125; PyUnicodeObject; 如上，定义了3种Objec结构体，具体功能及创建方式，见注释内容。 PyUnicode_Type123456789101112131415161718// unicodeobject.c.15170PyTypeObject PyUnicode_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "str", /* tp_name */ sizeof(PyUnicodeObject), /* tp_size */ 0, /* tp_itemsize */ /* Slots */ (destructor)unicode_dealloc, /* tp_dealloc */ ... unicode_repr, /* tp_repr */ &amp;unicode_as_number, /* tp_as_number */ &amp;unicode_as_sequence, /* tp_as_sequence */ &amp;unicode_as_mapping, /* tp_as_mapping */ (hashfunc) unicode_hash, /* tp_hash*/ ... unicode_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; 可见，PyUnicode_Type 就是 Python3 中的 str。 创建对象与 PyBytesObject 类似，PyUnicodeObject 也存在好几种创建方式，详见python.org。由于存在多种 Unicode OBject，各自的创建方式还不一样，下面分开查看。 PyUnicode_New12345678910111213141516171819202122232425262728293031// unicodeobject.c.1220PyObject * PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)&#123; PyObject *obj; PyCompactUnicodeObject *unicode; void *data; enum PyUnicode_Kind kind; int is_sharing, is_ascii; Py_ssize_t char_size; Py_ssize_t struct_size; ... /* 判断 获取变量的值 */ obj = (PyObject *) PyObject_MALLOC(struct_size + (size + 1) * char_size); obj = PyObject_INIT(obj, &amp;PyUnicode_Type); unicode = (PyCompactUnicodeObject *)obj; _PyUnicode_LENGTH(unicode) = size; _PyUnicode_HASH(unicode) = -1; _PyUnicode_STATE(unicode).interned = 0; _PyUnicode_STATE(unicode).kind = kind; _PyUnicode_STATE(unicode).compact = 1; _PyUnicode_STATE(unicode).ready = 1; _PyUnicode_STATE(unicode).ascii = is_ascii; ... /* 根据变量值, 赋值 unicode-&gt;utf8 = ? unicode-&gt;utf8_length = ? _PyUnicode_WSTR_LENGTH(unicode) = ? _PyUnicode_WSTR(unicode) = ? */ return obj;&#125; PyUnicode_New 是创建compact string的方式，代码很长，多数都是在容错处理。最终 MALLOC，然后赋初值，return。那么，问题来了，难道 Unicode Object 没有共享机制？ PyUnicode_FromUnicode12345678910111213141516171819202122232425// unicodeobject.c.1993PyObject * PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)&#123; PyObject *unicode; Py_UCS4 maxchar = 0; Py_ssize_t num_surrogates; if (u == NULL) return (PyObject*)_PyUnicode_New(size); /* 宏套宏，最终实现共享 unicode_empty=PyUnicode_New(0, 0); */ if (size == 0) _Py_RETURN_UNICODE_EMPTY(); /* 共享 Single character*/ if (size == 1 &amp;&amp; (Py_UCS4)*u &lt; 256) return get_latin1_char((unsigned char)*u); /* 创建新 not single 对象 */ unicode = PyUnicode_New(size - num_surrogates, maxchar); switch (PyUnicode_KIND(unicode)) &#123; /* case 不同 kind 执行执行相应的转换*/ &#125; return unicode_result(unicode);&#125; 如上，原始代码很长，上面只截取了相对重要的部分。好高兴，终于看到 Unicode 共享机制的苗头了，不过还得一个一个来看。 _PyUnicode_New12345678910111213141516171819202122232425262728293031323334353637383940414243// unicodeobject.c.1067static PyUnicodeObject * _PyUnicode_New(Py_ssize_t length)&#123; PyUnicodeObject *unicode; size_t new_size; /* 共享 empty strings */ if (length == 0 &amp;&amp; unicode_empty != NULL) &#123; Py_INCREF(unicode_empty); return (PyUnicodeObject*)unicode_empty; &#125; /* 容错代码(略)：length 不能过大，也不能 &lt; 0 */ // 创建对象 unicode = PyObject_New(PyUnicodeObject, &amp;PyUnicode_Type); new_size = sizeof(Py_UNICODE) * ((size_t)length + 1); // 赋初值 _PyUnicode_WSTR_LENGTH(unicode) = length; _PyUnicode_HASH(unicode) = -1; _PyUnicode_STATE(unicode).interned = 0; _PyUnicode_STATE(unicode).kind = 0; _PyUnicode_STATE(unicode).compact = 0; _PyUnicode_STATE(unicode).ready = 0; _PyUnicode_STATE(unicode).ascii = 0; _PyUnicode_DATA_ANY(unicode) = NULL; _PyUnicode_LENGTH(unicode) = 0; _PyUnicode_UTF8(unicode) = NULL; _PyUnicode_UTF8_LENGTH(unicode) = 0; // 真实数据 _PyUnicode_WSTR(unicode) = (Py_UNICODE*) PyObject_MALLOC(new_size); // 讨巧，只处理数组两端 _PyUnicode_WSTR(unicode)[0] = 0; _PyUnicode_WSTR(unicode)[length] = 0; return unicode;&#125;// 调用链：if (u == NULL) return (PyObject*)_PyUnicode_New(size); 源码依然很长，从整理后的代码可以看出，_PyUnicode_New 使用场景是：知道字符串长度，但不知道字符串的具体内容。只创建了内存空间，真实数据 ‘都是0’ 。 get_latin1_char(latin-1共享机制)123456789101112131415161718static PyObject* get_latin1_char(unsigned char ch)&#123; PyObject *unicode = unicode_latin1[ch]; if (!unicode) &#123; unicode = PyUnicode_New(1, ch); if (!unicode) return NULL; PyUnicode_1BYTE_DATA(unicode)[0] = ch; assert(_PyUnicode_CheckConsistency(unicode, 1)); unicode_latin1[ch] = unicode; &#125; Py_INCREF(unicode); return unicode;&#125;// 调用链：if (size == 1 &amp;&amp; (Py_UCS4)*u &lt; 256) return get_latin1_char((unsigned char)*u); 在上面的代码中，看到了熟悉的套路，一个数组unicode_latin1。1234// unicodeobject.c.213/* Single character Unicode strings in the Latin-1 range are being shared as well. */static PyObject *unicode_latin1[256] = &#123;NULL&#125;; 可见unicode_latin1数组，是一开始就创建，但并未填充数据，这就是单 unicode 的共享机制。 unicode_result123456789101112131415161718192021222324252627282930313233343536// unicodeobject.c.548static PyObject* unicode_result(PyObject *unicode)&#123; if (PyUnicode_IS_READY(unicode)) return unicode_result_ready(unicode); else return unicode_result_wchar(unicode);&#125;static PyObject* unicode_result_ready(PyObject *unicode)&#123; Py_ssize_t length; length = PyUnicode_GET_LENGTH(unicode); if (length == 0) &#123; // 共享 unicode_empty return unicode_empty; &#125; if (length == 1) &#123; void *data = PyUnicode_DATA(unicode); int kind = PyUnicode_KIND(unicode); Py_UCS4 ch = PyUnicode_READ(kind, data, 0); if (ch &lt; 256) &#123; // 共享 latin1_char return unicode; &#125; &#125; return unicode;&#125;// 调用链：/* 创建新 not single 对象 PyUnicode_New 中赋值 unicode.ready = 1; */unicode = PyUnicode_New(size - num_surrogates, maxchar);return unicode_result(unicode); 从上面的代码来看，似乎 unicode_result 对 PyUnicode_New 来说，纯粹是多余的。 从整个PyUnicode_FromUnicode来看，只是针对单latin-1字符，进行了共享。那就不能解释下面的代码：123456789101112&gt;&gt;&gt; a = 'abcde'&gt;&gt;&gt; b = 'abcde'&gt;&gt;&gt; id(a), id(b),id(a)==id(b)(1605538588408, 1605538588408, True)&gt;&gt;&gt; del a&gt;&gt;&gt; del b&gt;&gt;&gt; a = 'abcde'&gt;&gt;&gt; id(a)1605538115744&gt;&gt;&gt; b = 'abcde'&gt;&gt;&gt; id(a) == id(b)True Unicode 共享机制1234// unicodeobject.h.412#define SSTATE_NOT_INTERNED 0 // 未共享#define SSTATE_INTERNED_MORTAL 1 // 共享，不增加引用计数#define SSTATE_INTERNED_IMMORTAL 2 // 永久，不会被销毁 在上文的PyUnicode_New、_PyUnicode_New中，都进行了 unicode.interned = 0 赋值操作。在源码中发现 0 对应着不共享。 同时在 unicodeobject.c源码中，发现 4个可疑函数：1234void PyUnicode_InternInPlace(PyObject **p)void PyUnicode_InternImmortal(PyObject **p)PyObject * PyUnicode_InternFromString(const char *cp)void _Py_ReleaseInternedUnicodeStrings(void) 在 CPython 的其他源码中，大量存在类似true_str = PyUnicode_InternFromString(&quot;True&quot;)的代码，而PyUnicode_InternFromString内部又调用PyUnicode_InternInPlace。 PyUnicode_InternInPlace123456789101112131415161718192021222324252627282930313233343536373839// unicodeobject.c.174/* 注意，interned 不会影响 deallocation*/static PyObject *interned = NULL;static PyObject *unicode_empty = NULL;// unicodeobject.c.15278void PyUnicode_InternInPlace(PyObject **p)&#123; PyObject *s = *p; PyObject *t; // 类型检查，对子类 不共享 if (s == NULL || !PyUnicode_Check(s)) return; /* If it's a subclass, we don't really know what putting it in the interned dict might do. */ if (!PyUnicode_CheckExact(s)) return; if (PyUnicode_CHECK_INTERNED(s)) return; // 初始化 interned 字典 if (interned == NULL) &#123; interned = PyDict_New(); &#125; Py_ALLOW_RECURSION // ceval.h.113，保存线程 recursion_critical t = PyDict_SetDefault(interned, s, s); Py_END_ALLOW_RECURSION // 恢复 recursion_critical // 之前不存在 if (t != s) &#123; Py_INCREF(t); Py_SETREF(*p, t); return; &#125; // 已经存在 Py_REFCNT(s) -= 2; // k,v 各一次 _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL; // == 1&#125; 可以发现： 共享前会进行类型检查，共享历史检查 共享是用 interned 这个字典对象实现 PyDict_SetDefault 返回的是字典中对象的指针 若 t != s 即，字典中已经存在该值，对t 减引用，修改 *p 指向，返回 若 t ==s 即，字典中之前不存在，那么 放入字典，并设置 s.interned = 1 interned 字典中的指针，不作为对象的有效引用，因此执行 Py_REFCNT(s) -= 2 问题暂时解决了，利用 interned 字典+PyUnicode_Intern*实现了共享。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PyBytesObject</tag>
        <tag>PyUnicodeObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python源码剖析】PyLongObject/整数类型]]></title>
    <url>%2F2018%2F07%2F14%2FPython%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中所指 “前文”，皆指本人博客中【Python源码分析】中的系列文章 参考 《Python源码剖析》，感谢陈儒先生的著作 Python.org-Integer Objects，感谢Python社区的成果共享 PyLongObject在 Python2 中，存在 PyIntObject 和 PyLongObject 两种类型。前者是一个定长对象，后者是一个变长对象。Python3中 只存在后者。在 Python2 的结构体中 定义的是 long ob_ival，而 Python3 中定义的是只有1个元素的数组。1234567891011121314// longobject.h.10typedef struct _longobject PyLongObject;// longintrepr.h.85struct _longobject &#123; PyObject_VAR_HEAD digit ob_digit[1]; // digit 与平台相关，长度不一致&#125;;/* ob_size == 0 -&gt; zero ob_size &lt; 0 -&gt; 负数 PyLong_SHIFT == 30 or 15 value == SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i)*/ 由上可以看出，在 Python 中，整形的存储方式，是存储在一个数组中。因此通过控制 PyVarObject 的 ob_size 值，可以表示出非常非常大的数。 PyTypeObject12345678910111213// longobject.c.5431PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "int", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ... &amp;long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ long_new, /* tp_new */ PyObject_Del, /* tp_free */&#125;; 可见： int对象的类型对象是 PyLong_Type 从之前的 PyObject 分析也能得出 PyLong_Type的类型对象是 PyType_Type int对象，只支持 as_number，不支持作为序列、映射对象操作 123456789101112131415161718// longobject.c.5393static PyNumberMethods long_as_number = &#123; (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ ... long_float, /*nb_float*/ ...&#125;;// longobject.c.3108static PyObject *long_add(PyLongObject *a, PyLongObject *b)&#123; PyLongObject *z; .. // 检查，计算，返回 return (PyObject *)z;&#125; long_as_number 是前文所述 PyNumberMethods 函数簇的 一个结构体实例，初始化了大量方法。如上面的 long_add 操作，创建并返回一个新的 PyObject。 对象池 small_ints1234567891011121314151617181920// longobject.c.12#define NSMALLPOSINTS 257#define NSMALLNEGINTS 5static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS];// longobject.c.5514int _PyLong_Init(void)&#123; int ival, size; PyLongObject *v = small_ints; for (ival = -NSMALLNEGINTS; ival &lt; NSMALLPOSINTS; ival++, v++) &#123; size = (ival &lt; 0) ? -1 : ((ival == 0) ? 0 : 1); (void)PyObject_INIT(v, &amp;PyLong_Type); // Py_TYPE(op) = tp; Py_SIZE(v) = size; v-&gt;ob_digit[0] = (digit)abs(ival); &#125; return 1;&#125; 如上，当 Python 初始化时，_PyLong_Init 被调用，然后会 初始化 small_ints数组，作为小整数对象池来共享使用。 前面也提到了 _longobject 结构体中 定义的是 digit ob_digit[1]，从源码中可以发现： small_ints数组长度，默认[-5, 256] size 与 值的关系：小于0 or 等于0 or 大于0 小整数共享123456789101112131415// longobject.c.51#define CHECK_SMALL_INT(ival) \ do if (-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS) &#123; \ return get_small_int((sdigit)ival); \ &#125; while(0)// longobject.c.37static PyObject * get_small_int(sdigit ival)&#123; PyObject *v; assert(-NSMALLNEGINTS &lt;= ival &amp;&amp; ival &lt; NSMALLPOSINTS); v = (PyObject *)&amp;small_ints[ival + NSMALLNEGINTS]; Py_INCREF(v); return v;&#125; 如上，通过宏 CHECK_SMALL_INT，可以共享小整数。返回增加引用计数，并且返回指针。 创建对象1234567891011PyObject* PyLong_FromLong(long v)PyObject* PyLong_FromUnsignedLong(unsigned long v)PyObject* PyLong_FromSsize_t(Py_ssize_t v)PyObject* PyLong_FromSize_t(size_t v)PyObject* PyLong_FromLongLong(long long v)PyObject* PyLong_FromUnsignedLongLong(unsigned long long v)PyObject* PyLong_FromDouble(double v)PyObject* PyLong_FromString(const char *str, char **pend, int base)PyObject* PyLong_FromUnicode(Py_UNICODE *u, Py_ssize_t length, int base)PyObject* PyLong_FromUnicodeObject(PyObject *u, int base)PyObject* PyLong_FromVoidPtr(void *p) 在 CPython3.6.6 中，提供了大量创建 PyLongObject 的方法。下面，我们将查看其中一个。 PyLong_FromLong123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051PyObject * PyLong_FromLong(long ival)&#123; PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so &gt;&gt; doesn't propagate sign bit */ int ndigits = 0; int sign; CHECK_SMALL_INT(ival); // 宏，尝试小整数共享 // 处理得到 abs_ival(unsigned long) if (ival &lt; 0) &#123; /* negate: can't write this as abs_ival = -ival since that invokes undefined behaviour when ival is LONG_MIN */ abs_ival = 0U-(unsigned long)ival; sign = -1; &#125; else &#123; abs_ival = (unsigned long)ival; sign = ival == 0 ? 0 : 1; &#125; /* 处理 single-digit ints */ if (!(abs_ival &gt;&gt; PyLong_SHIFT)) &#123; v = _PyLong_New(1); if (v) &#123; Py_SIZE(v) = sign; v-&gt;ob_digit[0] = Py_SAFE_DOWNCAST(abs_ival, unsigned long, digit); // pyport.h.304: #define Py_SAFE_DOWNCAST(VALUE, WIDE, NARROW) (NARROW)(VALUE) &#125; return (PyObject*)v; &#125; /* Larger numbers: loop to determine number of digits */ t = abs_ival; while (t) &#123; ++ndigits; t &gt;&gt;= PyLong_SHIFT; &#125; v = _PyLong_New(ndigits); if (v != NULL) &#123; digit *p = v-&gt;ob_digit; Py_SIZE(v) = ndigits*sign; t = abs_ival; while (t) &#123; *p++ = Py_SAFE_DOWNCAST(t &amp; PyLong_MASK, unsigned long, digit); t &gt;&gt;= PyLong_SHIFT; &#125; &#125; return (PyObject *)v;&#125; 如上，创建一个 int 对象，主要有以下几个步骤： 尝试从对象池中获取 处理获取 abs_value 处理 single-digit 循环处理 Larger numbers 代码很简单，下面只看一下 _PyLong_New 具体逻辑。 _PyLong_New12345678910111213141516// longobject.c.179#define MAX_LONG_DIGITS \ ((PY_SSIZE_T_MAX - offsetof(PyLongObject, ob_digit))/sizeof(digit))PyLongObject * _PyLong_New(Py_ssize_t size)&#123; PyLongObject *result; if (size &gt; (Py_ssize_t)MAX_LONG_DIGITS) &#123; PyErr_SetString(PyExc_OverflowError, "too many digits in integer"); return NULL; &#125; result = PyObject_MALLOC(offsetof(PyLongObject, ob_digit) + size*sizeof(digit)); return (PyLongObject*)PyObject_INIT_VAR(result, &amp;PyLong_Type, size);&#125; 从代码可以看出，能够表示的最大整数是跟堆内存相关的，几乎可以表示无穷大的数了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>源码</tag>
        <tag>PyLongObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Python源码剖析】PyObject/PyObjectType]]></title>
    <url>%2F2018%2F07%2F14%2FPyObject%2F</url>
    <content type="text"><![CDATA[声明 文中所参考 Python 源码皆来自 CPython3.6.6 文中主要参考陈儒先生的著作，在正文中将不再重复声明 参考资料 《Python源码剖析》，感谢陈儒先生的著作 python.org，感谢Python社区的成果共享 Interface 123456789101112131415161718192021222324252627# object.h.8/* Object and type object interface */Objects are structures allocated on the heap.Objects are never allocated statically or on the stack;An object has a &apos;reference count&apos; that is increased or decreased when apointer to the object is copied or deleted;when the reference count reaches zero there are no references to the object leftand it can be removed from the heap.An object has a &apos;type&apos; that determines what it represents and what kindof data it contains. An object&apos;s type is fixed when it is created.Types themselves are represented as objects; an object contains apointer to the corresponding type object. The type itself has a typepointer pointing to the object representing the type &apos;type&apos;, whichcontains a pointer to itself!).once allocated an object keeps the same size and address.Objects that must hold variable-size data can contain pointers tovariable-size parts of the object.Objects are always accessed through pointers of the type &apos;PyObject *&apos;.The type &apos;PyObject&apos; is a structure that only contains the reference countand the type pointer.A standard interface exists for objects that contain an array of itemswhose size is determined when the object is allocated. 开篇一段注释，从注释中能提取到很多要点： 对象堆分配、从不栈分配 垃圾回收之引用计数 对象、类型对象、type 容器对象可变依据：持有指针 基石对象 PyObject 与类型转换 PyObject123456789101112// object.h.98typedef struct _object &#123; // ifdef Py_TRACE_REFS，定义双向链表存储所有堆上存活对象指针 _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; # 引用计数 struct _typeobject *ob_type; # 类型对象指针&#125; PyObject;typedef struct &#123; PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part，作 int 理解*/&#125; PyVarObject; 在 Python 中，实际上没有任何东西被声明为 PyObject，但所有对象都可以通过 PyObject 进行引用。类似的还有，指向容器的 PyVarObject 。 PyObject 结构体中包含： 指向类型对象 _typeobject 的指针 ob_type 用于垃圾回收的引用计数 ob_refcnt 对于容器对象，PyObject_VAR_HEAD 用 ob_size 代表元素个数。 PyTypeObject1234567891011121314151617181920212223242526272829// include.h.346typedef struct _typeobject &#123; PyObject_VAR_HEAD // #define PyObject_VAR_HEAD PyVarObject ob_base; const char *tp_name; /* For printing, in format "&lt;module&gt;.&lt;name&gt;" */ Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; /* Method suites for standard classes */ PyNumberMethods *tp_as_number; PySequenceMethods *tp_as_sequence; PyMappingMethods *tp_as_mapping; /* More standard operations (here for binary compatibility) */ /* Functions to access object as input/output buffer */ /* Flags to define presence of optional/expanded features */ /* Documentation string */ /* call function for all accessible objects */ /* delete references to contained objects */ /* weak reference enabler */ /* Iterators */ getiterfunc tp_iter; iternextfunc tp_iternext; /* Attribute descriptor and subclassing stuff */ struct PyMethodDef *tp_methods; struct PyMemberDef *tp_members;&#125; PyTypeObject; 创建对象之前，必须知道申请的内存空间大小，而这些元信息就存储在对象的类型对象中。含有头域PyObject_VAR_HEAD，表明类型对象本身是 可变长对象。结构体内存储大量信息，主要包括： 常规信息：类型名、Doc、tp_itemsize、tp_basicsize等 常规方法指针：tp_new、tp_init、tp_free等 函数簇：PyNumberMethods、PySequenceMethods等 123456// object.h.301typedef struct &#123; lenfunc mp_length; binaryfunc mp_subscript; objobjargproc mp_ass_subscript;&#125; PyMappingMethods; 在函数簇 PyMappingMethods 中，定义了支持映射的对象应该支持的操作。反过来说，一旦定义了 其中的方法，那么该对象就支持该方法。正因为 PyTypeObject 中同时定义了三种函数簇，所以才可以实现鸭子类型。 PyType_Type前面说过，PyVarObject -&gt; PyObject -&gt; PyTypeObject，但 PyTypeObject 内部又存在 PyVarObject。那么，这个内部的 VarObject 的 type 又是什么？此处先来看下 a = int(10) == 整型对象 a.ob_type == PyLong_Type PyLong_Type.ob_type == PyType_Type PyType_Type.ob_type == PyType_Type 123456789101112131415161718192021// object.h.85#define PyObject_HEAD_INIT(type) &#123; 1, type &#125;,#define PyVarObject_HEAD_INIT(type, size) &#123; PyObject_HEAD_INIT(type) size &#125;,// typeobject.c.3383PyTypeObject PyType_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) /* ob_base = &#123;ob_refcnt=1, *ob_type=PyType_Type&#125; ob_size = 0 */ "type", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ ... type_doc, /* tp_doc */ ... type_init, /* tp_init */ type_new, /* tp_new */ ...&#125;; 如上，可以看见 tp_name == ‘type’，即 Python 中 type 的类型对象就是 PyType_Type。第一句，&amp;PyType_Type 印证了 type(type)==type，形成自旋。 对于内建对象，Python 中有定义好的结构体，如 PyLongObject-&gt;PyLong_Type。而对于用户创建的类，就必须动态创建 type 对象。我们知道，创建类可以通过 type() 的方式生成，最终将调用 PyType_Type.type_new()。 PyBaseObject_Type1234567891011// typeobject.c.4535PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) "object", /* tp_name */ sizeof(PyObject), /* tp_basicsize */ object_methods, /* tp_methods */ object_init, /* tp_init */ PyType_GenericAlloc, /* tp_alloc */ object_new, /* tp_new */&#125;; 从上可以看出，object的类型对象就是PyBaseObject_Type。第一句，&amp;PyType_Type 印证了 type(object)==type，即 object 的类型对象，的类型对象是 PyType_Type。 object VS type这里要搞清楚的是： 对象，是通过 PyObject 结构体定义的，必须包含 ob_refcnt、ob_type 类型，PyBaseObject_Type、PyType_Type，本身也是可变对象 PyVarObject 普通对象的类型指针，ob_type，指向的是 类型对象：PyBaseObject_Type、PyType_Type 而 PyBaseObject_Type 本身也是对象，也具有 ob_type，指向的是 PyType_Type 最终 PyType_Type 也是对象，其 ob_type，指向的是 自身 123456789101112PyTypeObject PyList_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;list&quot;,&#125;PyTypeObject PyLong_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;int&quot;,&#125;PyTypeObject PyBaseObject_Type = &#123; PyVarObject_HEAD_INIT(&amp;PyType_Type, 0) &quot;object&quot;,&#125; 层次结构： 基石，PyObject，一切皆对象 最顶端的是 type，这也正是 type 被称为 metaclass 的原因。 内置对象 list/int/object等，其类型对象都是指向 type。 实例对象 int(1)，其类型对象是 PyLong_Type。 假设： 没有 1，好像可以照常用，只是不能创建 类了 没有 2, 也可以照常用，只是每次需要自己创建 int等基础类型 没有 3，不能实例化了，啥也干不了 容易混淆的是： object，既可以说是实例对象 3，又可以说是 类型对象 2，还可以说成 python对象 0 type，既可以说成实例对象3的类型对象 2，又可以说成元类 1 如果有人问，type 和 object 的关系，就得先问清楚他说的 type和object 指哪一个层面！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客开通啦]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在时间、成本、道德约束等各种抉择下，最终还是选择了github.io。嗯，安心写博客。]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>起风了</tag>
      </tags>
  </entry>
</search>
